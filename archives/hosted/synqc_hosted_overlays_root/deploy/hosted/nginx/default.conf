\
# Nginx hosted "edge" config for SynQc
# - Serves the static UI (your current ./web image)
# - Proxies /api/* to http://api:8001/*
# - Protects BOTH / and /api with oauth2-proxy using auth_request
#
# Notes:
# - Your frontend already defaults API_BASE to same-origin /api when on http(s), which matches this proxy.
# - For production, run TLS in front of this container (Cloudflare, ALB, Caddy/Traefik, etc.)
# - If you terminate TLS upstream, Origin checks below still work because we validate host, not scheme.

# Needed for WebSocket proxying
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

# Basic rate limits (tune to taste)
#  - general API traffic: 120 requests/min per IP
#  - expensive run endpoints: 20 requests/min per IP
limit_req_zone $binary_remote_addr zone=synqc_api_ratelimit:10m rate=120r/m;
limit_req_zone $binary_remote_addr zone=synqc_run_ratelimit:10m rate=20r/m;

server {
  listen 80;
  server_name _;

  # Small but meaningful hardening
  server_tokens off;
  client_max_body_size 1m;

  add_header X-Content-Type-Options "nosniff" always;
  add_header X-Frame-Options "DENY" always;
  add_header Referrer-Policy "no-referrer" always;
  add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;

  # If you add CSP, do it carefully because your UI has inline <style> and inline <script>.
  # Start permissive; tighten later.
  add_header Content-Security-Policy "default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self';" always;

  # --- oauth2-proxy endpoints ---
  location = /oauth2/auth {
    internal;
    proxy_pass       http://oauth2-proxy:4180/oauth2/auth;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-Uri   $request_uri;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host  $host;
  }

  location /oauth2/ {
    proxy_pass       http://oauth2-proxy:4180;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host  $host;
  }

  # --- UI (protected) ---
  location / {
    auth_request /oauth2/auth;
    error_page 401 = /oauth2/start?rd=$scheme://$host$request_uri;

    root /usr/share/nginx/html;
    try_files $uri $uri/ /index.html;
  }

  # --- API: SSE stream (protected + no buffering) ---
  location = /api/shor/runs/stream {
    auth_request /oauth2/auth;
    error_page 401 = @api_unauth;

    # Basic CSRF mitigation for state-changing requests:
    # - Allow GET/HEAD/OPTIONS always
    # - For others, require Origin host match
    set $csrf_ok 0;
    if ($request_method ~* "^(GET|HEAD|OPTIONS)$") { set $csrf_ok 1; }
    if ($http_origin ~* "^https?://$host(:\d+)?$") { set $csrf_ok 1; }
    if ($csrf_ok = 0) { return 403; }

    limit_req zone=synqc_api_ratelimit burst=60 nodelay;

    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Request-ID      $request_id;

    # Pass identity hints to the API (optional; implement server-side later)
    auth_request_set $auth_user  $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    proxy_set_header X-Auth-Request-User  $auth_user;
    proxy_set_header X-Auth-Request-Email $auth_email;

    proxy_read_timeout  3600s;
    proxy_send_timeout  3600s;

    proxy_buffering off;
    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://api:8001;
  }

  # --- API: WebSocket (protected) ---
  location = /api/shor/runs/ws {
    auth_request /oauth2/auth;
    error_page 401 = @api_unauth;

    # CSRF mitigation
    set $csrf_ok 0;
    if ($request_method ~* "^(GET|HEAD|OPTIONS)$") { set $csrf_ok 1; }
    if ($http_origin ~* "^https?://$host(:\d+)?$") { set $csrf_ok 1; }
    if ($csrf_ok = 0) { return 403; }

    limit_req zone=synqc_api_ratelimit burst=60 nodelay;

    proxy_http_version 1.1;
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;

    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Request-ID      $request_id;

    auth_request_set $auth_user  $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    proxy_set_header X-Auth-Request-User  $auth_user;
    proxy_set_header X-Auth-Request-Email $auth_email;

    proxy_read_timeout  3600s;

    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://api:8001;
  }

  # --- API: expensive run endpoint (protected + tighter rate limit) ---
  location = /api/experiments/run {
    auth_request /oauth2/auth;
    error_page 401 = @api_unauth;

    # CSRF mitigation (same host)
    set $csrf_ok 0;
    if ($request_method ~* "^(GET|HEAD|OPTIONS)$") { set $csrf_ok 1; }
    if ($http_origin ~* "^https?://$host(:\d+)?$") { set $csrf_ok 1; }
    if ($csrf_ok = 0) { return 403; }

    limit_req zone=synqc_run_ratelimit burst=10 nodelay;

    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Request-ID      $request_id;

    auth_request_set $auth_user  $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    proxy_set_header X-Auth-Request-User  $auth_user;
    proxy_set_header X-Auth-Request-Email $auth_email;

    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://api:8001;
  }

  # --- API: everything else (protected) ---
  location /api/ {
    auth_request /oauth2/auth;
    error_page 401 = @api_unauth;

    # CSRF mitigation
    set $csrf_ok 0;
    if ($request_method ~* "^(GET|HEAD|OPTIONS)$") { set $csrf_ok 1; }
    if ($http_origin ~* "^https?://$host(:\d+)?$") { set $csrf_ok 1; }
    if ($csrf_ok = 0) { return 403; }

    limit_req zone=synqc_api_ratelimit burst=60 nodelay;

    proxy_http_version 1.1;

    # WebSocket upgrades will work for any /api/* path that uses them
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;

    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Request-ID      $request_id;

    auth_request_set $auth_user  $upstream_http_x_auth_request_user;
    auth_request_set $auth_email $upstream_http_x_auth_request_email;
    proxy_set_header X-Auth-Request-User  $auth_user;
    proxy_set_header X-Auth-Request-Email $auth_email;

    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://api:8001;
  }

  location @api_unauth {
    default_type application/json;
    return 401 '{"detail":"unauthorized"}';
  }
}
