<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SynQc TDS — Temporal Dynamics Console v0.4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="assets/background.css" />
  <style>
    :root {
      --bg-main: #030308;
      --bg-panel: #0a0c16;
      --bg-panel-soft: #0f1220;
      --accent: #6ae5ff;
      --accent-strong: #ffdd6e;
      --text-main: #f6f7ff;
      --text-soft: #a6acd3;
      --border-subtle: #262b44;
      --kpi-good: #2ecc71;
      --kpi-warn: #ffb94d;
      --kpi-bad: #ff4d6a;
      --spectral-shift: 0deg;
      --hero-visual-max-width: 1200px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 50% 0%, #0b0e1c 0, #05060e 32%, #020208 72%, #000 100%);
      color: var(--text-main);
      overflow-x: hidden;
    }
    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .particle-layer {
      position: fixed;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: 0;
    }
    .spectralized {
      filter: hue-rotate(var(--spectral-shift, 0deg)) saturate(1.06);
      transition: filter 0.35s ease;
    }
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffffff, rgba(255,255,255,0));
      opacity: 0.7;
      animation: floatParticle 18s linear infinite;
    }
    .particle::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: inherit;
      background: radial-gradient(circle, rgba(106,229,255,0.45), transparent 60%);
      opacity: 0.4;
      filter: blur(2px);
    }
    @keyframes floatParticle {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 0.2; }
      20% { opacity: 0.7; }
      50% { transform: translate3d(40px, -60px, 0) scale(1.15); }
      80% { opacity: 0.4; }
      100%{ transform: translate3d(-20px,-120px,0) scale(0.9); opacity: 0; }
    }
    @keyframes pulseDot {
      0%, 100% { opacity: 0.45; }
      50% { opacity: 1; }
    }
    header {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.7rem 1.6rem;
      background: linear-gradient(to right, rgba(4,6,20,0.96), rgba(8,9,28,0.96));
      border-bottom: 1px solid var(--border-subtle);
      backdrop-filter: blur(18px);
    }
    .brand { display: flex; align-items: center; gap: 0.7rem; }
    .brand-logo {
      width: 30px; height: 30px; border-radius: 999px;
      background:
        radial-gradient(circle at 30% 25%, #ffffff, rgba(255,255,255,0) 55%),
        conic-gradient(from 140deg, #6ae5ff, #20e3b2, #ffdd6e, #6ae5ff);
      box-shadow: 0 0 16px rgba(106,229,255,0.8);
      position: relative;
    }
    .brand-logo::after {
      content: "";
      position: absolute; inset: 5px; border-radius: inherit;
      background: radial-gradient(circle at 70% 80%, rgba(32,227,178,0.5), transparent 55%);
      mix-blend-mode: screen;
    }
    .brand-text-title { font-weight: 600; letter-spacing: 0.04em; font-size: 1rem; }
    .brand-text-sub { font-size: 0.73rem; color: var(--text-soft); }
    .nav-links { display: flex; gap: 1.2rem; font-size: 0.83rem; }
    .nav-links button {
      background: none; border: none; color: var(--text-soft);
      cursor: pointer; padding: 0.3rem 0; position: relative;
    }
    .nav-links button.active, .nav-links button:hover { color: var(--text-main); }
    .nav-links button.active::after {
      content: ""; position: absolute; left: 0; right: 0; bottom: -0.35rem;
      height: 2px; border-radius: 999px;
      background: linear-gradient(to right, #6ae5ff, #ffdd6e);
    }
    .header-right { display: flex; align-items: center; gap: 1rem; font-size: 0.8rem; }
    .mode-toggle {
      display: inline-flex; align-items: center; gap: 0.2rem;
      padding: 0.2rem; border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: rgba(10,13,36,0.9);
    }
    .mode-pill {
      padding: 0.2rem 0.6rem; border-radius: 999px; cursor: pointer;
      font-size: 0.75rem; color: var(--text-soft);
    }
    .mode-pill.active {
      background: linear-gradient(to right, #6ae5ff, #ffdd6e);
      color: #050412; font-weight: 600;
    }
    .avatar {
      width: 28px; height: 28px; border-radius: 999px;
      display: inline-flex; align-items: center; justify-content: center;
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at 30% 20%, #6ae5ff, #151831);
      font-size: 0.75rem;
    }
    main {
      position: relative; z-index: 1; flex: 1;
      padding: 1rem 1.5rem 1.6rem;
    }

    .view { display: none; }
    .view.active { display: block; }

    .console-grid {
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(0, 1.9fr) minmax(260px, 0.9fr);
      grid-template-rows: repeat(2, minmax(260px, 1fr));
      grid-template-areas:
        "agent scene history"
        "agent scene qubits";
      gap: 1rem;
    }
    .run-alert {
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 8px;
      background: rgba(255, 77, 106, 0.12);
      border: 1px solid rgba(255, 77, 106, 0.25);
      color: #ffd1d9;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .run-alert .icon {
      display: inline-flex;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      align-items: center;
      justify-content: center;
      background: rgba(255, 77, 106, 0.22);
      color: #ff8aa1;
      font-weight: 700;
      font-size: 12px;
    }
    .health-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border-subtle);
      color: #c8d0ff;
      font-size: 12px;
    }
    .status-badge[data-state="warn"] {
      border-color: #ffb347;
      color: #ffd9a6;
      background: rgba(255, 179, 71, 0.12);
    }
    .status-badge[data-state="bad"] {
      border-color: #ff4d6a;
      color: #ffd1d9;
      background: rgba(255, 77, 106, 0.12);
    }
    .latency-overlay {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 8;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(8, 10, 30, 0.9);
      border: 1px solid var(--border-subtle);
      color: var(--text-soft);
      font-size: 12px;
      letter-spacing: 0.02em;
      backdrop-filter: blur(10px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    }
    .latency-overlay strong {
      color: var(--text-main);
      font-weight: 600;
    }
    @media (max-width: 1100px) {
      .console-grid {
        grid-template-columns: minmax(260px, 320px) minmax(0, 1.6fr);
        grid-template-rows: minmax(240px, auto) repeat(2, minmax(220px, 1fr));
        grid-template-areas:
          "scene scene"
          "agent history"
          "agent qubits";
      }
    }
    @media (max-width: 800px) {
      .console-grid {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto auto;
        grid-template-areas: "scene" "agent" "history" "qubits";
      }
    }
    .panel {
      background:
        radial-gradient(circle at 10% 0%, rgba(106,229,255,0.18), transparent 55%),
        linear-gradient(to bottom right, rgba(8,10,30,0.96), rgba(10,14,32,0.98));
      border-radius: 18px;
      border: 1px solid var(--border-subtle);
      padding: 0.85rem 0.9rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.55);
    }
    .panel-header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 0.6rem; gap: 0.5rem;
    }
    .panel-title {
      font-size: 0.85rem; text-transform: uppercase;
      letter-spacing: 0.14em; color: var(--text-soft);
    }
    .panel-sub { font-size: 0.75rem; color: var(--text-soft); opacity: 0.85; }
    .panel-agent { grid-area: agent; display: flex; flex-direction: column; gap: 0.6rem; }
    .agent-tabs {
      display: inline-flex; border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: rgba(6,8,25,0.9); font-size: 0.76rem;
    }
    .agent-tabs button {
      border: none; background: transparent; padding: 0.3rem 0.8rem;
      border-radius: 999px; cursor: pointer; color: var(--text-soft);
    }
    .agent-tabs button.active {
      background: linear-gradient(to right, #6ae5ff, #ffdd6e);
      color: #050412; font-weight: 600;
    }
    .agent-body {
      flex: 1; display: flex; flex-direction: column; gap: 0.6rem; min-height: 220px;
    }
    .agent-chat-log {
      flex: 1; border-radius: 14px;
      background: rgba(8,10,30,0.96);
      border: 1px solid var(--border-subtle);
      padding: 0.6rem 0.65rem;
      font-size: 0.78rem;
      display: flex; flex-direction: column; gap: 0.4rem;
      overflow-y: auto;
    }
    .msg { max-width: 100%; line-height: 1.35; white-space: pre-wrap; word-break: break-word; }
    .msg-user { color: #6ae5ff; }
    .msg-agent{ color: var(--text-soft); }
    .agent-input-row {
      display: flex; gap: 0.4rem; margin-top: 0.1rem;
    }
    .agent-input-row input {
      flex: 1; border-radius: 999px; border: 1px solid var(--border-subtle);
      background: rgba(10,13,34,0.96);
      padding: 0.85rem 0.9rem; font-size: 0.86rem; min-height: 52px;
      color: var(--text-main); outline: none;
    }
    .agent-input-row input::placeholder { color: var(--text-soft); }
    .agent-input-row button {
      border-radius: 999px; border: none; padding: 0.4rem 0.8rem;
      font-size: 0.78rem; cursor: pointer;
      background: linear-gradient(to right, #6ae5ff, #ffdd6e);
      color: #050412; font-weight: 600;
    }

.primary-btn {
  border-radius: 12px;
  border: none;
  padding: 0.5rem 0.75rem;
  font-size: 0.8rem;
  cursor: pointer;
  background: linear-gradient(to right, #6ae5ff, #ffdd6e);
  color: #050412;
  font-weight: 700;
}
.primary-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

    .agent-setup {
      border-radius: 14px; border: 1px solid var(--border-subtle);
      background: rgba(8,10,29,0.96);
      padding: 0.55rem 0.6rem; font-size: 0.78rem;
      display: flex; flex-direction: column; gap: 0.4rem;
    }
    .field-row { display: flex; flex-direction: column; gap: 0.15rem; }
    .field-label { font-size: 0.74rem; color: var(--text-soft); }
    .field-input, .field-select {
      border-radius: 10px; border: 1px solid var(--border-subtle);
      background: #07091c; color: var(--text-main);
      padding: 0.3rem 0.45rem; font-size: 0.78rem; outline: none;
    }
    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.7rem;
      margin-top: 0.4rem;
    }
    .panel-controls { grid-column: 1 / -1; }
    .control-card {
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: rgba(7,9,26,0.96);
      padding: 0.55rem 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .control-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.45rem;
      font-size: 0.8rem;
    }
    .control-value { color: var(--accent); font-weight: 700; }
    .control-slider {
      width: 100%;
      accent-color: #ff8297;
    }
    .control-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.8rem;
    }
    .control-actions {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }
    .control-status {
      font-size: 0.8rem;
      color: var(--text-soft);
    }
    .panel-scene { grid-area: scene; display: flex; flex-direction: column; gap: 0.7rem; }
    .scene-top {
      display: flex; justify-content: space-between;
      align-items: center; gap: 0.7rem; flex-wrap: wrap;
    }
    .scene-kpis { display: flex; gap: 0.4rem; flex-wrap: wrap; }
    .kpi-card {
      min-width: 90px; border-radius: 12px; padding: 0.4rem 0.5rem;
      background: rgba(10,13,34,0.96);
      border: 1px solid var(--border-subtle);
      font-size: 0.72rem;
    }
    .kpi-label { color: var(--text-soft); margin-bottom: 0.1rem; }
    .kpi-value { font-size: 0.9rem; font-weight: 600; }
    .kpi-good { color: var(--kpi-good); }
    .kpi-warn { color: var(--kpi-warn); }
    .kpi-bad  { color: var(--kpi-bad); }
    .scene-main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(200px, 0.9fr);
      gap: 0.8rem; align-items: stretch;
    }
    @media (max-width: 900px) {
      .scene-main { grid-template-columns: minmax(0, 1fr); }
    }
    .scene-visual {
      border-radius: 16px; border: 1px solid var(--border-subtle);
      background:
        radial-gradient(circle at 15% 10%, rgba(255,255,255,0.12), transparent 60%),
        radial-gradient(circle at 80% 90%, rgba(106,229,255,0.18), transparent 60%),
        #050616;
      padding: 0.7rem; position: relative; overflow: hidden;
      display: flex; flex-direction: column; gap: 0.6rem;
    }
    .scene-bloch-block { display: flex; flex-direction: column; gap: 0.45rem; }
    .dpd-chip-row {
      display: flex;
      justify-content: center;
      padding-top: 0.1rem;
    }
    .dpd-label {
      position: relative;
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-soft);
      background: rgba(5,6,20,0.92);
      padding: 0.28rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(123,132,200,0.5);
      box-shadow: 0 6px 22px rgba(0,0,0,0.35);
    }
    .bloch-wrapper {
      display: flex; align-items: center; justify-content: center; padding-top: 0.2rem;
    }
    .bloch-sphere {
      width: 190px; height: 190px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,0.35), rgba(255,255,255,0) 55%),
        radial-gradient(circle at 70% 80%, rgba(106,229,255,0.55), rgba(106,229,255,0) 60%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0.9), rgba(0,0,0,1));
      position: relative;
      box-shadow: 0 0 25px rgba(0,0,0,0.85);
    }
    .bloch-equator, .bloch-meridian {
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      border: 1px dashed rgba(200,210,255,0.35);
    }
    .bloch-equator { width: 130px; height: 130px; }
    .bloch-meridian{ width: 130px; height: 130px; transform: translate(-50%,-50%) rotateY(80deg); }
    .bloch-state {
      position: absolute; width: 10px; height: 10px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffffff, rgba(255,255,255,0));
      box-shadow: 0 0 12px rgba(255,255,255,0.8);
      animation: stateOrbit 8s ease-in-out infinite;
      transform-origin: 50% 50%;
    }
    .bloch-axis-z {
      position: absolute; left: 50%; top: 8%;
      width: 2px; height: 84%;
      transform: translateX(-50%);
      background: linear-gradient(to bottom, rgba(255,255,255,0.2), rgba(255,255,255,0));
      opacity: 0.6;
    }
    @keyframes stateOrbit {
      0%   { transform: translate(80px, 10px)   scale(1); }
      25%  { transform: translate(20px, -70px)  scale(1.1); }
      50%  { transform: translate(-75px, -5px)  scale(0.95); }
      75%  { transform: translate(-20px, 70px)  scale(1.05); }
      100% { transform: translate(80px, 10px)   scale(1); }
    }
    .scene-timeline {
      font-size: 0.75rem; color: var(--text-soft);
      display: flex; flex-direction: column; gap: 0.5rem;
    }
    .timeline-bar {
      display: flex; align-items: center; gap: 0.35rem; margin-top: 0.2rem;
    }
    .segment {
      height: 10px; border-radius: 999px; position: relative;
      background: rgba(255,255,255,0.07); flex-shrink: 0;
    }
    .segment-drive  { flex: 0.8; background: linear-gradient(to right, rgba(106,229,255,0.9), rgba(32,227,178,0.8)); }
    .segment-probe  { flex: 0.5; background: linear-gradient(to right, rgba(255,221,110,0.9), rgba(255,173,76,0.85)); }
    .segment-drive2 { flex: 0.7; background: linear-gradient(to right, rgba(32,227,178,0.9), rgba(106,229,255,0.85)); }
    .segment-label { font-size: 0.7rem; color: var(--text-soft); }
    .scene-notes { font-size: 0.73rem; color: var(--text-soft); opacity: 0.85; line-height: 1.4; }

    .neural-stack {
      margin-top: 0;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at 18% 10%, rgba(106,229,255,0.12), transparent 45%),
        radial-gradient(circle at 82% 86%, rgba(255,221,110,0.14), transparent 45%),
        rgba(7,9,26,0.92);
      padding: 0.65rem 0.75rem;
      box-shadow: inset 0 0 18px rgba(255,255,255,0.03), 0 20px 45px rgba(0,0,0,0.55);
      display: flex;
      flex-direction: column;
      flex: 0 0 auto;
      width: 100%;
    }
    .neural-wide { margin-top: 0.1rem; }
    .neural-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .neural-title {
      font-weight: 650;
      letter-spacing: 0.02em;
      font-size: 0.95rem;
    }
    .neural-progress {
      font-size: 0.82rem;
      color: var(--accent);
      font-weight: 700;
    }
    @media (max-width: 600px) {
      .neural-head { gap: 0.3rem; }
      .neural-title { letter-spacing: 0.01em; }
    }
    @media (max-width: 520px) {
      .neural-progress { font-size: 0.76rem; }
    }
    .neural-web {
      position: relative;
      margin-top: 0.55rem;
      min-height: clamp(180px, 28vw, 260px);
      border-radius: 14px;
      background:
        linear-gradient(120deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0.02) 36%, rgba(255,255,255,0.04) 72%, rgba(255,255,255,0.02) 100%),
        radial-gradient(circle at 30% 40%, rgba(106,229,255,0.14), transparent 40%),
        radial-gradient(circle at 70% 60%, rgba(255,221,110,0.16), transparent 55%),
        rgba(4,6,20,0.98);
      border: 1px solid rgba(255,255,255,0.06);
      overflow: hidden;
      perspective: 1200px;
      transform-style: preserve-3d;
      transform: rotateX(18deg) rotateY(-16deg);
      box-shadow: inset 0 0 32px rgba(255,255,255,0.02), 0 14px 36px rgba(0,0,0,0.55);
      flex: 1;
    }
    .neural-web::after {
      content: "";
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 2px, transparent 12px, transparent 16px),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.015) 0px, rgba(255,255,255,0.015) 2px, transparent 12px, transparent 16px);
      opacity: 0.25;
      pointer-events: none;
    }
    .neural-node {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 30% 30%, #ffffff, rgba(255,255,255,0)),
        radial-gradient(circle at 70% 70%, rgba(106,229,255,0.9), rgba(106,229,255,0));
      box-shadow:
        0 0 12px rgba(106,229,255,0.75),
        0 0 32px rgba(106,229,255,0.4);
      transform: translate3d(var(--x, 0px), var(--y, 0px), var(--z, 0px));
      transition: transform 0.4s ease, box-shadow 0.3s ease, opacity 0.3s ease;
      opacity: 0.62;
    }
    .neural-node .node-label {
      position: absolute;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.68rem;
      color: var(--text-soft);
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 1px 6px rgba(0,0,0,0.65);
    }
    .neural-node.active {
      opacity: 1;
      box-shadow:
        0 0 14px rgba(255,221,110,0.9),
        0 0 40px rgba(255,221,110,0.5),
        0 0 78px rgba(106,229,255,0.35);
      transform: translate3d(var(--x, 0px), var(--y, 0px), var(--z, 0px)) scale(1.08);
    }
    .neural-node.completed {
      opacity: 1;
      box-shadow:
        0 0 16px rgba(106,229,255,0.95),
        0 0 50px rgba(106,229,255,0.45),
        0 0 90px rgba(255,221,110,0.28);
    }
    .neural-link {
      position: absolute;
      height: 2px;
      background: linear-gradient(to right, rgba(106,229,255,0.0), rgba(106,229,255,0.8), rgba(255,221,110,0.85));
      opacity: 0.45;
      box-shadow: 0 0 10px rgba(106,229,255,0.35);
      transform-origin: 0 50%;
      transition: opacity 0.3s ease, box-shadow 0.3s ease;
    }
    .neural-link.active {
      opacity: 0.9;
      box-shadow: 0 0 14px rgba(255,221,110,0.85);
    }
    .neural-context {
      margin-top: 0.75rem;
      border-radius: 12px;
      padding: 0.8rem 0.85rem;
      background: rgba(5,6,20,0.9);
      border: 1px solid rgba(255,255,255,0.08);
      display: flex;
      align-items: flex-start;
      gap: 0.45rem;
      min-height: 110px;
    }
    .context-chip {
      padding: 0.14rem 0.5rem;
      border-radius: 999px;
      background: linear-gradient(to right, rgba(106,229,255,0.35), rgba(255,221,110,0.35));
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 0.72rem;
      color: #0a0d20;
      font-weight: 700;
    }
    .context-body {
      font-size: 0.88rem;
      color: var(--text-main);
      line-height: 1.35;
      flex: 1;
    }
    @media (max-width: 720px) {
      .neural-stack { padding: 0.55rem 0.6rem; gap: 0.35rem; }
      .neural-web { min-height: clamp(150px, 36vw, 220px); }
      .neural-context { padding: 0.65rem 0.7rem; }
    }
    .panel-history { grid-area: history; display: flex; flex-direction: column; gap: 0.6rem; }
    .panel-history, .panel-qubits { min-height: 360px; }
    .history-filters {
      display: flex; flex-wrap: wrap; gap: 0.35rem; font-size: 0.72rem;
    }
    .filter-pill {
      padding: 0.18rem 0.45rem; border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: rgba(7,9,26,0.95);
      color: var(--text-soft); cursor: pointer;
    }
    .filter-pill.active { border-color: #6ae5ff; color: #6ae5ff; }
    .history-table-wrap {
      flex: 1; border-radius: 14px; border: 1px solid var(--border-subtle);
      background: rgba(8,10,30,0.96);
      padding: 0.4rem 0.45rem;
      font-size: 0.75rem; overflow-y: auto;
    }
    table { width: 100%; border-spacing: 0; border-collapse: collapse; }
    th, td { padding: 0.3rem 0.25rem; text-align: left; white-space: nowrap; }
    th {
      color: var(--text-soft); font-weight: 500; font-size: 0.72rem;
      border-bottom: 1px solid var(--border-subtle);
      position: sticky; top: 0; background: rgba(7,9,26,0.97); z-index: 1;
    }
    tbody tr { border-bottom: 1px solid rgba(25,30,60,0.9); }
    tbody tr:hover { background: rgba(106,229,255,0.07); }
    .status-pill {
      padding: 0.12rem 0.4rem; border-radius: 999px; font-size: 0.7rem;
    }
    .status-ok   { background: rgba(46,204,113,0.18); color: var(--kpi-good); }
    .status-warn { background: rgba(255,185,77,0.18); color: var(--kpi-warn); }
    .status-fail { background: rgba(255,77,106,0.18); color: var(--kpi-bad); }
    .history-footer-note {
      margin-top: 0.25rem; font-size: 0.7rem; color: var(--text-soft); opacity: 0.9;
    }
    .panel-qubits { grid-area: qubits; display: flex; flex-direction: column; gap: 0.55rem; }
    .qubit-headline {
      display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; flex-wrap: wrap;
    }
    .qubit-count { font-size: 1.05rem; font-weight: 700; color: var(--accent); }
    .qubit-session { font-size: 0.8rem; color: var(--text-soft); }
    .qubit-lattice {
      position: relative;
      min-height: 210px;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at 30% 20%, rgba(106,229,255,0.12), transparent 50%), rgba(6,8,25,0.92);
      overflow: hidden;
    }
    .qubit-lattice::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 70% 80%, rgba(255,221,110,0.12), transparent 45%);
      pointer-events: none;
    }
    .qubit-node {
      position: absolute;
      width: 28px; height: 32px;
      clip-path: polygon(25% 5%, 75% 5%, 100% 50%, 75% 95%, 25% 95%, 0% 50%);
      background: linear-gradient(140deg, rgba(106,229,255,0.82), rgba(255,221,110,0.8));
      box-shadow:
        0 0 10px rgba(106,229,255,0.7),
        0 0 28px rgba(106,229,255,0.3);
      opacity: 0.9;
      transform: translate(-50%, -50%) scale(0.94);
      animation: qubitPulse 2.8s ease-in-out infinite;
    }
    .qubit-node.demo {
      background: linear-gradient(140deg, rgba(106,229,255,0.55), rgba(255,221,110,0.6));
      box-shadow:
        0 0 6px rgba(106,229,255,0.55),
        0 0 18px rgba(106,229,255,0.25);
    }
    .qubit-node.pulse {
      animation-duration: 1.6s;
      box-shadow:
        0 0 14px rgba(255,221,110,0.85),
        0 0 34px rgba(106,229,255,0.5);
    }
    .qubit-node.glow {
      filter: drop-shadow(0 0 12px rgba(106,229,255,0.45));
    }
    @keyframes qubitPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(0.92); opacity: 0.82; }
      50% { transform: translate(-50%, -50%) scale(1.06); opacity: 1; }
    }
    .qubit-footnote {
      font-size: 0.75rem;
      color: var(--text-soft);
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      background: rgba(5,7,20,0.85);
      padding: 0.55rem 0.6rem;
      line-height: 1.35;
    }
    @media (max-width: 640px) {
      .panel-history, .panel-qubits { min-height: 320px; }
      .history-table-wrap { min-height: 180px; }
      .qubit-lattice { min-height: 240px; }
    }
    footer {
      position: relative; z-index: 1;
      padding: 0.7rem 1.6rem 1rem;
      font-size: 0.7rem; color: var(--text-soft);
      border-top: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top, rgba(18,24,64,0.96), rgba(6,7,20,0.98));
    }
  
    /* --------------------------------------------
       Visual detail upgrades (v0.3)
       - Decorative layers are aria-hidden
       - Animation speeds are adjustable from JS based on KPIs
       -------------------------------------------- */
    .panel-credit{
      margin-top: 0.55rem;
      font-size: 0.72rem;
      color: rgba(215,225,255,0.72);
      letter-spacing: 0.02em;
      text-align: right;
      opacity: 0.9;
      user-select: none;
    }

    .bloch-atmosphere{
      position:absolute;
      inset: -18px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 30% 30%, rgba(106,229,255,0.35), rgba(106,229,255,0) 55%),
        radial-gradient(circle at 70% 80%, rgba(32,227,178,0.25), rgba(32,227,178,0) 60%),
        radial-gradient(circle at 50% 50%, rgba(255,255,255,0.12), rgba(255,255,255,0));
      filter: blur(10px);
      opacity: 0.38;
      animation: glowPulse 6.5s ease-in-out infinite;
      pointer-events:none;
      z-index: 0;
    }
    @keyframes glowPulse {
      0%, 100% { transform: scale(0.98); filter: blur(10px); }
      50%      { transform: scale(1.02); filter: blur(12px); }
    }

    .bloch-noise{
      position:absolute;
      inset: 0;
      border-radius: 999px;
      background:
        radial-gradient(circle at 20% 15%, rgba(255,255,255,0.06), rgba(255,255,255,0) 40%),
        radial-gradient(circle at 75% 85%, rgba(106,229,255,0.08), rgba(106,229,255,0) 45%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 2px, rgba(0,0,0,0) 6px, rgba(0,0,0,0) 10px);
      opacity: 0.0;
      mix-blend-mode: screen;
      animation: noiseDrift 5.8s ease-in-out infinite;
      pointer-events:none;
      z-index: 1;
    }
    @keyframes noiseDrift{
      0%   { transform: translate(0px, 0px) rotate(0deg); }
      50%  { transform: translate(2px, -3px) rotate(8deg); }
      100% { transform: translate(0px, 0px) rotate(0deg); }
    }

    .bloch-ring{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      border: 1px solid rgba(200,210,255,0.18);
      box-shadow: 0 0 14px rgba(106,229,255,0.10);
      pointer-events:none;
      z-index: 2;
      animation: ringSpinA 16s linear infinite;
    }
    .bloch-ring.ring-a{
      width: 170px; height: 170px;
      border-style: dotted;
      opacity: 0.55;
      animation-name: ringSpinA;
    }
    .bloch-ring.ring-b{
      width: 140px; height: 140px;
      border-style: dashed;
      opacity: 0.42;
      animation-name: ringSpinB;
      animation-duration: 22s;
    }
    .bloch-ring.ring-c{
      width: 110px; height: 110px;
      border-style: solid;
      opacity: 0.28;
      animation-name: ringSpinC;
      animation-duration: 30s;
    }

    @keyframes ringSpinA{
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to   { transform: translate(-50%, -50%) rotate(360deg); }
    }
    @keyframes ringSpinB{
      from { transform: translate(-50%, -50%) rotate(35deg) skewX(10deg); }
      to   { transform: translate(-50%, -50%) rotate(395deg) skewX(10deg); }
    }
    @keyframes ringSpinC{
      from { transform: translate(-50%, -50%) rotate(75deg) skewY(12deg); }
      to   { transform: translate(-50%, -50%) rotate(435deg) skewY(12deg); }
    }

    .bloch-trace{
      position:absolute;
      left: 50%;
      top: 50%;
      width: 170px;
      height: 170px;
      transform: translate(-50%, -50%);
      opacity: 0.55;
      z-index: 3;
      animation: traceSpin 20s linear infinite;
      pointer-events:none;
    }
    @keyframes traceSpin{
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to   { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .trace-path{
      fill: none;
      stroke: rgba(255,221,110,0.50);
      stroke-width: 0.85;
      stroke-dasharray: 4 7;
      animation: traceDash 3.6s linear infinite;
      filter: drop-shadow(0 0 5px rgba(255,221,110,0.12));
    }
    .trace-path2{
      stroke: rgba(32,227,178,0.36);
      stroke-dasharray: 2 6;
      animation-duration: 4.4s;
    }
    @keyframes traceDash{
      to { stroke-dashoffset: -70; }
    }

    .bloch-orbit-dot{
      position:absolute;
      left: 50%;
      top: 50%;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffffff, rgba(255,255,255,0));
      box-shadow: 0 0 10px rgba(106,229,255,0.65);
      transform: translate(88px, 0px);
      transform-origin: -88px 0px;
      animation: orbitDot 7.5s linear infinite;
      opacity: 0.75;
      pointer-events:none;
      z-index: 6;
    }
    @keyframes orbitDot{
      from { transform: translate(88px, 0px) rotate(0deg); }
      to   { transform: translate(88px, 0px) rotate(360deg); }
    }

    /* Timeline motion cue (DPD "spark") */
    .timeline-animated{
      position: relative;
      overflow: hidden;
    }
    .timeline-spark{
      position: absolute;
      left: -25%;
      top: 50%;
      width: 22%;
      height: 2px;
      transform: translateY(-50%);
      background: linear-gradient(to right, rgba(0,0,0,0), rgba(106,229,255,0.90), rgba(0,0,0,0));
      opacity: 0.75;
      filter: blur(0.3px);
      animation: sparkMove 4.2s linear infinite;
      pointer-events:none;
    }
    @keyframes sparkMove{
      from { left: -25%; }
      to   { left: 100%; }
    }

    /* Small enhancement: allow the state animation speed to be set from JS */
    .bloch-state{
      animation-duration: 8s;
      z-index: 7;
    }


    /* --------------------------------------------
       View pages (v0.4)
       -------------------------------------------- */
    .page-wrap{
      max-width: 1100px;
      margin: 0 auto;
    }

    .small-btn{
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: rgba(10,13,34,0.96);
      color: var(--text-main);
      padding: 0.35rem 0.7rem;
      font-size: 0.78rem;
      cursor: pointer;
    }
    .small-btn:hover{
      border-color: rgba(106,229,255,0.65);
    }

    .hardware-list{
      margin-top: 0.65rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.7rem;
    }
    .hardware-item{
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: rgba(8,10,30,0.96);
      padding: 0.6rem 0.65rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }
    .hardware-top{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .hardware-name{
      font-weight: 650;
      font-size: 0.86rem;
      letter-spacing: 0.01em;
    }
    .hardware-badge{
      font-size: 0.68rem;
      padding: 0.14rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(123,132,200,0.55);
      color: rgba(215,225,255,0.8);
      background: rgba(7,9,26,0.9);
      white-space: nowrap;
    }
    .hardware-meta{
      font-size: 0.74rem;
      color: var(--text-soft);
    }

    .detail-actions{
      display: flex;
      gap: 0.45rem;
      align-items: center;
    }

    .json-block{
      margin-top: 0.45rem;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: rgba(7,9,26,0.96);
      padding: 0.6rem 0.7rem;
      font-size: 0.75rem;
      color: rgba(240,243,255,0.92);
      overflow: auto;
      max-height: 44vh;
    }

    .hint{
      font-size: 0.72rem;
      color: rgba(215,225,255,0.78);
      opacity: 0.92;
    }

    .grover-callout{
      margin-top: 0.4rem;
      padding: 0.55rem 0.7rem;
      border-radius: 12px;
      border: 1px solid rgba(109,132,255,0.4);
      background: radial-gradient(circle at 20% 20%, rgba(117,207,255,0.14), rgba(60,78,126,0.28));
      display: flex;
      gap: 0.6rem;
      align-items: flex-start;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
    }

    .grover-icon{
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: linear-gradient(135deg, #7cf7ff, #9aa8ff);
      color: #0b1533;
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 12px rgba(124,247,255,0.75);
      font-size: 0.9rem;
      flex-shrink: 0;
    }

    .grover-callout strong{
      color: #e8ecff;
      letter-spacing: 0.01em;
    }

    /* Shor panel */
    .panel-shor {
      border: 1px solid var(--border-subtle);
      box-shadow: 0 18px 38px rgba(0,0,0,0.4);
      grid-column: 1 / -1;
      width: 100%;
      min-height: 320px;
      overflow: auto;
    }
    .shor-meta { display: flex; gap: 0.35rem; align-items: center; flex-wrap: wrap; justify-content: flex-end; }
    .shor-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--border-subtle);
      color: var(--text-soft);
      font-size: 0.75rem;
    }
    .shor-chip::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(135deg, #6ae5ff, #ffdd6e);
      display: inline-block;
    }
    .shor-chip[data-state="warn"] { border-color: #ffb347; color: #ffd9a6; }
    .shor-chip[data-state="bad"] { border-color: #ff4d6a; color: #ffd1d9; }
    .shor-status { font-size: 0.78rem; color: var(--text-soft); }
    .shor-status strong { color: var(--text-main); }
    .shor-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.3fr) minmax(0, 0.9fr);
      grid-template-rows: minmax(0, 1fr) minmax(0, 0.9fr);
      grid-template-areas:
        "controls telemetry"
        "controls workspace";
      gap: 0.8rem;
      align-items: stretch;
    }
    @media (max-width: 1100px) {
      .shor-layout {
        grid-template-columns: minmax(0, 1fr);
        grid-template-areas:
          "controls"
          "telemetry"
          "workspace";
      }
    }
    .shor-card {
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: rgba(7,9,26,0.94);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .shor-card h3 { margin: 0; font-size: 0.95rem; letter-spacing: 0.02em; }
    .shor-card-control { grid-area: controls; }
    .shor-card-output { grid-area: telemetry; }
    .shor-workspace { grid-area: workspace; gap: 0.5rem; position: relative; min-height: 260px; }
    .shor-workspace::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 14px;
      pointer-events: none;
      background: radial-gradient(circle at 75% 85%, rgba(106,229,255,0.12), transparent 40%);
      opacity: 0.8;
    }
    .shor-workspace h3 { display: flex; align-items: center; gap: 0.35rem; }
    .shor-workspace h3 .chip {
      font-size: 0.7rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border-subtle);
      color: var(--text-soft);
      letter-spacing: 0.05em;
    }
    .shor-workspace .panel-sub { margin-top: -0.2rem; }
    .workspace-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.45rem; position: relative; z-index: 1; }
    .workspace-tile {
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      background: rgba(255,255,255,0.03);
      padding: 0.45rem 0.55rem;
      display: grid;
      gap: 0.25rem;
    }
    .workspace-label { font-size: 0.72rem; color: var(--text-soft); letter-spacing: 0.01em; }
    .workspace-value { font-size: 0.9rem; font-weight: 600; color: var(--text-main); word-break: break-word; }
    .workspace-note { width: 100%; position: relative; z-index: 1; }
    .workspace-note .shor-textarea { min-height: 110px; }
    .workspace-status { font-size: 0.75rem; color: var(--text-soft); display: flex; align-items: center; gap: 0.35rem; position: relative; z-index: 1; }
    .workspace-status::before { content: "●"; color: #6ae5ff; font-size: 0.65rem; transition: color 0.2s ease, opacity 0.2s ease; }
    .workspace-status[data-state="queued"]::before { color: var(--kpi-warn); animation: pulseDot 1.2s ease-in-out infinite; }
    .workspace-status[data-state="running"]::before { color: var(--accent-strong); animation: pulseDot 1.2s ease-in-out infinite; }
    .workspace-status[data-state="fail"]::before { color: var(--kpi-bad); animation: none; }
    .workspace-status[data-state="ok"]::before { color: var(--kpi-good); animation: none; }
    .shor-grid-fields { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 0.55rem; }
    .shor-grid-fields label { font-size: 0.75rem; color: var(--text-soft); }
    .shor-input, .shor-select, .shor-textarea {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      background: #07091c;
      color: var(--text-main);
      padding: 0.35rem 0.45rem;
      font-size: 0.8rem;
      outline: none;
    }
    .shor-textarea { min-height: 70px; resize: vertical; }
    .shor-actions { display: flex; flex-wrap: wrap; gap: 0.4rem; }
    .shor-btn { border-radius: 10px; border: 1px solid var(--border-subtle); padding: 0.45rem 0.7rem; font-size: 0.78rem; background: rgba(255,255,255,0.03); color: var(--text-main); cursor: pointer; }
    .shor-btn.primary { background: linear-gradient(to right, #6ae5ff, #ffdd6e); color: #050412; font-weight: 700; border: none; }
    .shor-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .shor-callout { border-radius: 12px; border: 1px solid rgba(106,229,255,0.35); background: rgba(10,16,32,0.9); padding: 0.65rem; font-size: 0.82rem; color: var(--text-soft); }
    .shor-output { border-radius: 12px; border: 1px solid var(--border-subtle); background: rgba(5,7,18,0.96); padding: 0.6rem; font-size: 0.78rem; color: rgba(240,243,255,0.92); min-height: 180px; white-space: pre-wrap; word-break: break-word; }
    .shor-runs { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.45rem; }
    .shor-run { border-radius: 12px; border: 1px solid var(--border-subtle); background: rgba(255,255,255,0.03); padding: 0.5rem; display: flex; flex-direction: column; gap: 0.25rem; cursor: pointer; text-align: left; }
    .shor-run__top { display: flex; justify-content: space-between; font-size: 0.78rem; color: var(--text-soft); }
    .shor-run__bot { display: flex; justify-content: space-between; font-size: 0.8rem; }
    .shor-run--bad { border-color: #ff4d6a; }
    .shor-run__status { text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700; }
    .shor-help { font-size: 0.74rem; color: var(--text-soft); line-height: 1.5; }
    .shor-guardrail { grid-column: 1 / -1; font-size: 0.75rem; color: #ffd9a6; background: rgba(255, 179, 71, 0.12); border: 1px solid rgba(255, 179, 71, 0.35); padding: 0.35rem 0.5rem; border-radius: 10px; }

</style>
</head>
<body>
    <div class="app">
      <div class="particle-layer spectralized" id="particleLayer"></div>
      <div class="background-layer" aria-hidden="true"></div>

    <header>
      <div class="brand">
        <div class="brand-logo"></div>
        <div>
          <div class="brand-text-title">SynQc TDS</div>
          <div class="brand-text-sub">Temporal Dynamics Console</div>
        </div>
      </div>

      <nav class="nav-links" aria-label="Primary">
        <button class="active" data-view="console">Console</button>
        <button data-view="experiments">Experiments</button>
        <button data-view="hardware">Hardware</button>
        <button data-view="details">Details</button>
      </nav>

      <div class="header-right">
        <div class="mode-toggle">
          <div class="mode-pill active" data-mode="explore">Explore</div>
          <div class="mode-pill" data-mode="calibrate">Calibrate</div>
          <div class="mode-pill" data-mode="prod">Production</div>
        </div>
        <div class="avatar">SynQc</div>
      </div>
    </header>

    <main>
      <div class="view active" id="view-console">
        <div class="console-grid">
<section class="panel panel-agent">
        <div class="panel-header">
          <div>
            <div class="panel-title">SynQc Guide</div>
            <div class="panel-sub">Agent & experiment setup</div>
          </div>
          <div class="agent-tabs">
            <button class="active" data-tab="chat">Agent</button>
            <button data-tab="setup">Setup</button>
          </div>
        </div>

        <div class="agent-body">
          <div class="grover-callout" aria-label="Grover search capability">
            <span class="grover-icon" title="Grover badge">ψ</span>
            <div>
              <div><strong>Grover search ready</strong> — the Agent can dispatch a full Grover preset to the backend so you get real circuit results instead of a toy simulator.</div>
              <div class="panel-sub">Use the Grover preset below or ask the Agent to “run Grover search” to exercise the Qiskit/Aer path.</div>
            </div>
          </div>
          <div class="agent-chat-log" id="agentChatLog">
            <div class="msg msg-agent">
              <strong>SynQc Guide:</strong> Welcome. Tell me what you want to learn or test.
              Examples: “Run a coherence health check”, “Measure latency”, “Compare this backend
              to the simulator”, or “Walk me through a full SynQc DPD example.”
            </div>
          </div>

          <div class="agent-input-row">
            <input id="agentInput" type="text" placeholder="Describe your goal, e.g. 'Check coherence on IBM simulator'…" />
            <button id="agentSend">Send</button>
          </div>

          <div class="agent-setup" id="agentSetupPanel" style="display:none;">
            <div class="field-row">
              <div class="field-label">Hardware target</div>
              <select class="field-select" id="hardwareSelect">
                <option value="sim_local">Local simulator</option>
                <option value="aws_braket">AWS Braket</option>
                <option value="ibm_quantum">IBM Quantum</option>
                <option value="azure_quantum">Microsoft Azure Quantum</option>
                <option value="ionq_cloud">IonQ Cloud</option>
                <option value="rigetti_forest">Rigetti Forest</option>
              </select>
              <div class="panel-sub" id="hardwareCapabilityHint">Loading capabilities…</div>
            </div>
            <div class="field-row">
              <div class="field-label">Experiment preset</div>
              <select class="field-select" id="presetSelect">
                <option value="hello_quantum_sim">Hello Quantum (Sim)</option>
                <option value="health">Qubit Health Diagnostics (T1/T2/RB)</option>
                <option value="latency">Latency Characterization</option>
                <option value="grover_demo">Grover search (Qiskit/Aer)</option>
                <option value="backend_compare">Backend A/B Comparison</option>
                <option value="grover_demo">Grover energy search (demo)</option>
                <option value="dpd_demo">Guided SynQc DPD Example</option>
              </select>
            </div>
            <div class="field-row">
              <div class="field-label" id="shotLabel">Shot budget (max)</div>
              <input class="field-input" id="shotInput" type="number" value="2048" />
            </div>
<div class="field-row">
  <div class="field-label">Notes</div>
  <textarea class="field-input" id="notesInput" rows="3" placeholder="Optional notes (chip ID, temperature, goal)…"></textarea>
  <div class="panel-sub">
    These controls represent high-level intent. Detailed pulse-level configuration,
    timing windows, and safety limits are handled by the SynQc engine and hardware backends.
  </div>
</div>

<div class="field-row">
  <div class="field-label">API key (dev only)
    <span class="hint" title="Passing API keys via URL or storing in localStorage can leak secrets via browser history and shared links. Use only for dev/short-lived tokens.">?</span>
  </div>
  <div class="panel-sub">
    The UI reads <code>?api_key=...</code> once to seed <code>localStorage</code> (keys: <code>synqc_api_key</code> / <code>synqc_bearer_token</code>), then removes it from the URL. Avoid embedding long-lived secrets in URLs or localStorage for production.
  </div>
  <div class="panel-sub warning" id="urlKeyWarning" style="display:none;">
    API key detected in URL. It will be stored locally and the URL cleaned.
  </div>
</div>

    <div class="field-row">
      <div class="field-label">Actions</div>
      <button class="primary-btn" id="runPresetBtn" type="button">Run preset</button>
      <div class="panel-sub" id="runStatus" aria-live="polite">Backend: not connected yet.</div>
      <div class="health-badges" id="healthBadges" aria-live="polite"></div>
      <div class="run-alert" id="runAlert" role="alert" style="display:none;">
        <span class="icon" aria-hidden="true">!</span>
        <span class="alert-text"></span>
      </div>
      <div class="panel-credit">Developed by eVision Enterprises</div>
</div>
</div>
        </div>
      </section>

      <section class="panel panel-scene">
        <div class="panel-header">
          <div>
            <div class="panel-title">Quantum Scene & KPIs</div>
            <div class="panel-sub">Drive–Probe–Drive (DPD) temporal dynamics view</div>
          </div>
        </div>
        <div class="scene-top">
          <div class="scene-kpis">
            <div class="kpi-card">
              <div class="kpi-label">Fidelity</div>
              <div class="kpi-value kpi-good" id="kpiFidelity">0.972</div>
            </div>
            <div class="kpi-card">
              <div class="kpi-label">Latency</div>
              <div class="kpi-value" id="kpiLatency">18.4 µs</div>
            </div>
            <div class="kpi-card">
              <div class="kpi-label">Backaction</div>
              <div class="kpi-value kpi-warn" id="kpiBackaction">0.21</div>
            </div>
            <div class="kpi-card">
              <div class="kpi-label">Shots used</div>
              <div class="kpi-value" id="kpiShots">1.2k / 2.0k</div>
            </div>
          </div>
          <div class="panel-sub">
            Current preset: <strong id="scenePresetLabel">Qubit Health Diagnostics</strong> ·
            Hardware: <strong id="sceneHardwareLabel">Local simulator</strong>
          </div>
        </div>
        <div class="scene-main">
          <div class="scene-visual spectralized">
            <div class="dpd-chip-row">
              <div class="dpd-label">Drive · Probe · Drive</div>
            </div>
            <div class="scene-bloch-block">
              <div class="bloch-wrapper">
                <div class="bloch-sphere spectralized" aria-label="Bloch sphere state visualization">
                  <div class="bloch-atmosphere" id="blochAtmosphere" aria-hidden="true"></div>
                  <div class="bloch-noise" id="blochNoise" aria-hidden="true"></div>
                  <div class="bloch-ring ring-a" id="blochRingA" aria-hidden="true"></div>
                  <div class="bloch-ring ring-b" id="blochRingB" aria-hidden="true"></div>
                  <div class="bloch-ring ring-c" id="blochRingC" aria-hidden="true"></div>

                  <svg class="bloch-trace" id="blochTrace" viewBox="0 0 100 100" aria-hidden="true">
                    <path class="trace-path" d="M10 50 C 25 15, 75 15, 90 50 C 75 85, 25 85, 10 50 Z"></path>
                    <path class="trace-path trace-path2" d="M20 50 C 32 28, 68 28, 80 50 C 68 72, 32 72, 20 50 Z"></path>
                  </svg>

                  <div class="bloch-equator"></div>
                  <div class="bloch-meridian"></div>
                  <div class="bloch-axis-z"></div>
                  <div class="bloch-state" id="blochState"></div>
                  <div class="bloch-orbit-dot" id="blochOrbitDot" aria-hidden="true"></div>
                </div>
              </div>
              <div class="scene-notes">
                This visualization represents the effective state of a single qubit under a SynQc
                Drive–Probe–Drive (DPD) protocol. The moving point suggests how your combined drive,
                probe, and feedback operations move the state on (and off) the Bloch sphere in time.
              </div>
            </div>
          </div>
          <div class="scene-timeline spectralized">
            <div>
              <strong>Temporal sequence</strong>
              <div class="panel-sub">
                High-level structure of the current SynQc experiment bundle.
              </div>
              <div class="timeline-bar timeline-animated">
                <div class="timeline-spark" id="timelineSpark" aria-hidden="true"></div>
                <div class="segment segment-drive"></div>
                <div class="segment segment-probe"></div>
                <div class="segment segment-drive2"></div>
              </div>
              <div class="timeline-bar">
                <span class="segment-label">Drive</span>
                <span class="segment-label">Probe (measurement / partial)</span>
                <span class="segment-label">Drive / Feedback</span>
              </div>
            </div>
            <div>
              <strong>Interpretation snapshot</strong>
              <div class="scene-notes" id="sceneInterpretation">
                No experiment has been run in this session yet. When you run a SynQc preset,
                this panel will summarize what was learned about coherence, latency, or backend
                behavior in plain language, derived from the raw KPIs.
              </div>
            </div>
          </div>
        </div>
        <div class="neural-stack spectralized neural-wide" aria-label="SynQc orchestration neural network">
          <div class="neural-head">
            <div>
              <div class="panel-sub">Neural orchestrator</div>
              <div class="neural-title">Temporal dynamics workflow</div>
            </div>
            <div class="neural-progress" id="workflowProgressValue">0%</div>
          </div>
          <div class="neural-web" id="neuralWeb" aria-hidden="true"></div>
          <div class="neural-context">
            <div class="context-chip">Live context</div>
            <div class="context-body" id="workflowContext">Waiting for the next SynQc run…</div>
          </div>
        </div>
      </section>

      <section class="panel panel-history">
        <div class="panel-header">
          <div>
            <div class="panel-title">Experiment Runs</div>
            <div class="panel-sub">Recent SynQc temporal dynamics bundles</div>
          </div>
        </div>
        <div class="history-filters" id="historyFiltersConsole">
          <div class="filter-pill active" data-filter="all">All</div>
          <div class="filter-pill" data-filter="health">Health</div>
          <div class="filter-pill" data-filter="latency">Latency</div>
          <div class="filter-pill" data-filter="compare">Compare</div>
          <div class="filter-pill" data-filter="grover">Grover search</div>
          <div class="filter-pill" data-filter="dpd">DPD demo</div>
          <div class="filter-pill" data-filter="shor">Shor crypto</div>
          <div class="filter-pill" data-filter="failing">Failing targets</div>
        </div>
        <div class="history-footer-note" id="failingTargetsConsole"></div>
        <div class="history-table-wrap">
          <table>
            <thead>
              <tr>
                <th>Time</th>
                <th>Preset</th>
                <th>Hardware</th>
                <th>Fidelity</th>
                <th>Latency</th>
                <th>Controls</th>
                <th>Error code</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <tr>
                <td>14:02:11</td>
                <td>Health (T1/T2/RB)</td>
                <td>Sim local</td>
                <td>0.973</td>
                <td>17.9 µs</td>
                <td>drive 1.00 · gain 0.35 · clamp 600 ns</td>
                <td>—</td>
                <td><span class="status-pill status-ok">OK</span></td>
              </tr>
              <tr>
                <td>13:38:42</td>
                <td>Latency probe</td>
                <td>Sim local</td>
                <td>–</td>
                <td>15.1 µs</td>
                <td>drive 1.00 · gain 0.35 · clamp 600 ns</td>
                <td>—</td>
                <td><span class="status-pill status-ok">OK</span></td>
              </tr>
              <tr>
                <td>12:27:05</td>
                <td>Backend compare</td>
                <td>Sim vs IBM Quantum</td>
                <td>0.962 / 0.948</td>
                <td>18.4 / 26.7 µs</td>
                <td>drive 1.00 · gain 0.35 · clamp 600 ns</td>
                <td>—</td>
                <td><span class="status-pill status-warn">Δ drift</span></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="history-footer-note">
          In a live deployment, each row links to full analysis, raw pulse/circuit definitions,
          and provider logs. This HTML file is a UI shell; the SynQc backend is responsible for
          running real experiments and storing data.
        </div>
      </section>
      <section class="panel panel-qubits spectralized">
        <div class="panel-header qubit-headline">
          <div>
            <div class="panel-title">Qubit entanglement footprint</div>
            <div class="panel-sub">Hexagonal lattice preview for live runs</div>
          </div>
          <div class="qubit-session" id="qubitSessionTotal">Session total: —</div>
        </div>
        <div class="qubit-count" id="qubitCountDisplay">Demo: 1–25 qubits</div>
        <div class="qubit-lattice" id="qubitLattice" aria-label="Qubit lattice visualization"></div>
        <div class="qubit-footnote" id="qubitNote">
          Waiting for backend data. A looping demo shows 1–25 qubits in a SynQc-styled lattice until live runs complete.
        </div>
      </section>
      <section class="panel panel-controls">
        <div class="panel-header">
          <div>
            <div class="panel-title">Engineering controls</div>
            <div class="panel-sub">Manual adjustments for drive/probe/feedback behavior</div>
          </div>
          <div class="panel-sub" id="controlMeta">Live profile</div>
        </div>
        <div class="control-grid">
          <div class="control-card">
            <div class="control-head">
              <div>Drive bias</div>
              <div class="control-value" id="driveBiasValue">1.00x</div>
            </div>
            <input type="range" min="0.5" max="1.5" step="0.01" value="1" id="driveBiasInput" class="control-slider" aria-label="Drive bias multiplier" />
            <div class="panel-sub">Scales drive amplitude across the DPD bundle.</div>
          </div>
          <div class="control-card">
            <div class="control-head">
              <div>Probe window</div>
              <div class="control-value" id="probeWindowValue">120 ns</div>
            </div>
            <input type="range" min="10" max="5000" step="10" value="120" id="probeWindowInput" class="control-slider" aria-label="Probe window length (ns)" />
            <div class="panel-sub">Duration of mid-circuit measurement segment.</div>
          </div>
          <div class="control-card">
            <div class="control-head">
              <div>Feedback gain</div>
              <div class="control-value" id="feedbackGainValue">0.35</div>
            </div>
            <input type="range" min="0" max="3" step="0.05" value="0.35" id="feedbackGainInput" class="control-slider" aria-label="Feedback gain" />
            <div class="panel-sub">Applied during the final drive/feedback leg.</div>
          </div>
          <div class="control-card">
            <div class="control-head">
              <div>Safety clamp</div>
              <div class="control-value" id="safetyClampValue">600 ns</div>
            </div>
            <input type="range" min="0" max="20000" step="50" value="600" id="safetyClampInput" class="control-slider" aria-label="Safety clamp duration (ns)" />
            <div class="panel-sub">Upper bound for composite pulse trains. 0 disables the clamp.</div>
          </div>
          <div class="control-card">
            <div class="control-head">
              <div>Color spectrum shift</div>
              <div class="control-value" id="spectralShiftValue">0°</div>
            </div>
            <input type="range" min="-180" max="180" step="1" value="0" id="spectralShiftInput" class="control-slider" aria-label="Color spectrum hue shift (°)" />
            <div class="panel-sub">Hue-rotates all animated layers together for quick palette testing.</div>
          </div>
          <div class="control-card">
            <div class="control-head">
              <div>Guards &amp; notes</div>
            </div>
            <label class="control-toggle">
              <input type="checkbox" id="thermalGuardToggle" checked /> Thermal guard enabled
            </label>
            <textarea class="field-input" rows="3" id="controlNotesInput" placeholder="Operator notes for this control profile"></textarea>
            <div class="panel-sub">Guardrails stay on for production unless explicitly disabled.</div>
          </div>
        </div>
        <div class="control-actions">
          <button class="primary-btn" type="button" id="applyControlsBtn">Apply to backend</button>
          <div class="control-status" id="controlStatus">Awaiting backend profile…</div>
        </div>
      </section>
      <section class="panel panel-shor spectralized" id="shorPanel">
        <div class="panel-header">
          <div>
            <div class="panel-title">Shor's Algorithm</div>
            <div class="panel-sub">Quantum RSA encryption/factoring surface backed by /shor/* endpoints</div>
          </div>
          <div class="shor-meta">
            <div class="shor-chip" id="shorBackendChip" data-state="warn">/shor health: pending</div>
            <div class="shor-status" id="shorStatus">Awaiting backend check…</div>
            <button class="small-btn" type="button" id="shorHealthBtn">Recheck</button>
          </div>
        </div>
        <div class="shor-layout">
          <div class="shor-card shor-card-control">
            <h3>Quantum control surface</h3>
            <div class="shor-callout">
              Use the controls below to generate guard-railed RSA keys, encrypt payloads, and drive Shor factoring/decryption against the backend. Hardware modes require your bearer token; the panel falls back to classical factoring when quantum hardware is unavailable.
            </div>
            <div class="shor-grid-fields">
              <label for="shorPrimeBits">Prime bits</label>
              <input class="shor-input" id="shorPrimeBits" type="number" value="12" min="4" step="1" />

              <label for="shorModulus">N (modulus)</label>
              <input class="shor-input" id="shorModulus" placeholder="e.g. 3233" />

              <label for="shorExponent">e (public exponent)</label>
              <input class="shor-input" id="shorExponent" placeholder="65537" value="65537" />

              <label for="shorPlainInt">Plaintext (int)</label>
              <input class="shor-input" id="shorPlainInt" placeholder="integer plaintext" />

              <label for="shorPlainText">Plaintext (text)</label>
              <input class="shor-input" id="shorPlainText" placeholder="UTF-8 text" />

              <label for="shorCiphertext">Ciphertext (int)</label>
              <input class="shor-input" id="shorCiphertext" placeholder="ciphertext integer" />
            </div>

            <div class="shor-grid-fields">
              <label for="shorMethodSelect">Method</label>
              <select class="shor-select" id="shorMethodSelect">
                <option value="auto">auto (prefer Qiskit Shor)</option>
                <option value="qiskit">qiskit (force Shor path)</option>
                <option value="classical">classical fallback</option>
              </select>

              <label for="shorBackendSelect">Qiskit backend</label>
              <select class="shor-select" id="shorBackendSelect">
                <option value="aer">aer (local simulator)</option>
                <option value="ibm">ibm (IBM Runtime)</option>
                <option value="custom">custom provider</option>
              </select>

              <label for="shorShotsInput">Shots</label>
              <input class="shor-input" id="shorShotsInput" type="number" value="1024" min="1" max="20000" />

              <label for="shorIbmBackend">IBM backend name</label>
              <input class="shor-input" id="shorIbmBackend" placeholder="e.g. ibm_oslo" />

              <label for="shorProviderLoader">Provider loader (optional)</label>
              <input class="shor-input" id="shorProviderLoader" placeholder="module:Class" />

              <label for="shorProviderBackend">Provider backend name</label>
              <input class="shor-input" id="shorProviderBackend" placeholder="provider backend (required for custom)" />

              <div class="shor-guardrail" id="shorLimitNote">Guardrails: auto/aer capped near N≈32k, IBM/custom capped near N≈4k.</div>
            </div>

            <div class="shor-actions">
              <button class="shor-btn" id="shorGenerateBtn" type="button">Generate demo RSA key</button>
              <button class="shor-btn primary" id="shorEncryptBtn" type="button">Encrypt</button>
              <button class="shor-btn" id="shorDecryptBtn" type="button">Decrypt (factor N)</button>
              <button class="shor-btn" id="shorEstimateBtn" type="button">Estimate resources</button>
              <button class="shor-btn" id="shorFactorBtn" type="button">Factor N</button>
            </div>

            <div class="shor-help">
              <div>• Backend guardrails enforce small N for demos; plaintext must be &lt; N.</div>
              <div>• IBM/custom modes expect your bearer token (synqc_bearer_token or api_key) and backend names.</div>
              <div>• Output captures raw responses so you can inspect factoring steps and runtime.</div>
            </div>
          </div>
          <div class="shor-card shor-card-output">
            <h3>Telemetry</h3>
            <div class="shor-status" id="shorRunStatus">Live output from /shor endpoints.</div>
            <pre class="shor-output" id="shorOutput">{}</pre>
            <div class="panel-sub" style="margin-top:0.2rem;">Recent runs (/shor/runs)</div>
            <div class="shor-runs" id="shorRuns"></div>
            <div class="shor-actions">
              <button class="shor-btn" id="shorReloadRunsBtn" type="button">Reload runs</button>
              <button class="shor-btn" id="shorOpenLatestBtn" type="button">Open latest</button>
            </div>
          </div>
          <div class="shor-card shor-workspace">
            <h3>Workspace <span class="chip">live mirror</span></h3>
            <div class="panel-sub">Use this scratchpad to stage inputs from your plugged-in system and watch Shor settings update in real time.</div>
            <div class="workspace-note">
              <textarea class="shor-textarea" id="shorWorkspaceNotes" data-shor-keep-enabled="true" placeholder="Commands, notes, or intermediate ciphertexts…"></textarea>
            </div>
            <div class="workspace-grid" aria-live="polite">
              <div class="workspace-tile">
                <div class="workspace-label">Modulus (N)</div>
                <div class="workspace-value" id="shorWorkspaceModulus">—</div>
              </div>
              <div class="workspace-tile">
                <div class="workspace-label">Exponent (e)</div>
                <div class="workspace-value" id="shorWorkspaceExponent">—</div>
              </div>
              <div class="workspace-tile">
                <div class="workspace-label">Backend / method</div>
                <div class="workspace-value" id="shorWorkspaceBackend">—</div>
              </div>
              <div class="workspace-tile">
                <div class="workspace-label">Plaintext</div>
                <div class="workspace-value" id="shorWorkspacePlaintext">—</div>
              </div>
              <div class="workspace-tile">
                <div class="workspace-label">Ciphertext</div>
                <div class="workspace-value" id="shorWorkspaceCiphertext">—</div>
              </div>
              <div class="workspace-tile">
                <div class="workspace-label">Shots &amp; guardrail</div>
                <div class="workspace-value" id="shorWorkspaceShots">—</div>
              </div>
            </div>
            <div class="workspace-status" id="shorWorkspaceStatus">Waiting for input…</div>
          </div>
        </div>
      </section>
        </div>
      </div>

      <div class="view" id="view-experiments">
        <div class="page-wrap">
          <section class="panel">
            <div class="panel-header">
              <div>
                <div class="panel-title">Experiments</div>
                <div class="panel-sub">Backed by <code>GET /experiments/recent</code> · Click a row to open <strong>Details</strong></div>
              </div>
              <button class="small-btn" id="refreshExperimentsBtn" type="button">Reload</button>
            </div>

            <div class="history-filters" id="historyFiltersExperiments">
              <div class="filter-pill active" data-filter="all">All</div>
              <div class="filter-pill" data-filter="health">Health</div>
              <div class="filter-pill" data-filter="latency">Latency</div>
              <div class="filter-pill" data-filter="compare">Compare</div>
              <div class="filter-pill" data-filter="grover">Grover search</div>
              <div class="filter-pill" data-filter="dpd">DPD demo</div>
              <div class="filter-pill" data-filter="shor">Shor crypto</div>
              <div class="filter-pill" data-filter="failing">Failing targets</div>
            </div>

            <div class="history-footer-note" id="failingTargetsExperiments"></div>

            <div class="history-table-wrap">
              <table>
                <thead>
                  <tr>
                    <th>Time</th>
                    <th>ID</th>
                    <th>Preset</th>
                    <th>Hardware</th>
                    <th>Fidelity</th>
                    <th>Latency</th>
                    <th>Controls</th>
                    <th>Error code</th>
                    <th>Status</th>
                  </tr>
                </thead>
            <tbody id="experimentsBody">
              <tr><td colspan="9" class="hint">No data loaded yet. Start the backend and click Reload.</td></tr>
            </tbody>
          </table>
            </div>

            <div class="history-footer-note" id="experimentsFooterNote">
              This view is intentionally read-only: the current backend exposes run + list + fetch endpoints, but no delete/edit endpoints.
            </div>
          </section>
        </div>
      </div>

      <div class="view" id="view-hardware">
        <div class="page-wrap">
          <section class="panel">
            <div class="panel-header">
              <div>
                <div class="panel-title">Hardware targets</div>
                <div class="panel-sub">Backed by <code>GET /hardware/targets</code></div>
              </div>
              <button class="small-btn" id="refreshHardwareBtn" type="button">Reload</button>
            </div>

            <div class="panel-sub" id="hardwareMeta">Backend capability loads from <code>/health</code>.</div>
            <div class="hardware-list" id="hardwareList" role="list"></div>

            <div class="history-footer-note">
              The frontend Setup dropdown is populated from this same endpoint to ensure the controls match backend capability.
            </div>
          </section>
        </div>
      </div>

      <div class="view" id="view-details">
        <div class="page-wrap">
          <section class="panel">
            <div class="panel-header">
              <div>
                <div class="panel-title">Experiment details</div>
                <div class="panel-sub">Backed by <code>GET /experiments/{id}</code> · This is the closest thing to “Logs” supported by the current API.</div>
              </div>
              <div class="detail-actions">
                <button class="small-btn" id="detailsBackBtn" type="button">Back</button>
                <button class="small-btn" id="detailsReloadBtn" type="button">Reload</button>
              </div>
            </div>

            <div class="panel-sub" id="detailsHeader">No experiment selected yet. Go to Experiments and click a row.</div>

            <div class="scene-kpis" style="margin-top:0.55rem;"> 
              <div class="kpi-card">
                <div class="kpi-label">Fidelity</div>
                <div class="kpi-value" id="detailsKpiFidelity">—</div>
              </div>
              <div class="kpi-card">
                <div class="kpi-label">Latency</div>
                <div class="kpi-value" id="detailsKpiLatency">—</div>
              </div>
              <div class="kpi-card">
                <div class="kpi-label">Backaction</div>
                <div class="kpi-value" id="detailsKpiBackaction">—</div>
              </div>
              <div class="kpi-card">
                <div class="kpi-label">Shots used</div>
                <div class="kpi-value" id="detailsKpiShots">—</div>
              </div>
              <div class="kpi-card">
                <div class="kpi-label">Status</div>
                <div class="kpi-value" id="detailsKpiStatus">—</div>
              </div>
            </div>

            <div class="scene-notes" id="detailsInterpretation" style="margin-top:0.6rem;">Select a run to see a plain-language summary here.</div>
            <div class="panel-sub" id="detailsControlProfile" style="margin-top:0.4rem;">Active controls: —</div>

            <div class="panel-sub" style="margin-top:0.7rem;">Raw record</div>
            <pre class="json-block" id="detailsJson">{}</pre>
          </section>
        </div>
      </div>
    </main>

    <div class="latency-overlay" id="latencyOverlay" aria-live="polite">
      API latency: <strong id="latencyValue">--</strong>
    </div>

    <footer>
      SynQc TDS is the front-end console for SynQc Temporal Dynamics Series — bridging Drive–Probe–Drive
      theory, mid-circuit measurement, and real hardware backends into a single, guided control experience.
      This file is a production-ready frontend shell and requires a backend API to execute real experiments.
    </footer>
  </div>

  <script>
    // --------------------------------------------
    // Visual particles
    // --------------------------------------------
    (function initParticles() {
      const layer = document.getElementById('particleLayer');
      const count = 30;
      for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        const x = Math.random() * 100;
        const y = 20 + Math.random() * 80;
        const delay = Math.random() * 18;
        const scale = 0.8 + Math.random() * 0.7;
        p.style.left = x + 'vw';
        p.style.top = y + 'vh';
        p.style.animationDelay = (-delay) + 's';
        p.style.transform = 'scale(' + scale.toFixed(2) + ')';
        layer.appendChild(p);
      }
    })();

    // --------------------------------------------
    // Mode pills
    // --------------------------------------------
    document.querySelectorAll('.mode-pill').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-pill').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // --------------------------------------------
    // Primary nav -> view switching (v0.4)
    // --------------------------------------------
    const navButtons = Array.from(document.querySelectorAll('.nav-links button[data-view]'));
    const views = {
      console: document.getElementById('view-console'),
      experiments: document.getElementById('view-experiments'),
      hardware: document.getElementById('view-hardware'),
      details: document.getElementById('view-details'),
    };

    let lastNonDetailsView = 'console';

    function setActiveView(viewName, { pushHash = true } = {}) {
      if (!views[viewName]) viewName = 'console';

      navButtons.forEach(b => b.classList.toggle('active', b.dataset.view === viewName));
      Object.entries(views).forEach(([k, el]) => {
        if (!el) return;
        el.classList.toggle('active', k === viewName);
      });

      if (viewName !== 'details') lastNonDetailsView = viewName;

      if (pushHash) {
        try { window.location.hash = viewName; } catch (_) { /* ignore */ }
      }

      // Best-effort refresh when opening data-backed views
      if (viewName === 'experiments') refreshExperimentsView();
      if (viewName === 'hardware') refreshHardwareView();
      if (viewName === 'details') refreshDetailsView();
    }

    navButtons.forEach(btn => {
      btn.addEventListener('click', () => setActiveView(btn.dataset.view || 'console'));
    });

    // Initialize from hash
    (function initViewFromHash(){
      const hv = (window.location.hash || '').replace('#','').trim();
      if (hv && views[hv]) setActiveView(hv, { pushHash: false });
    })();

    // --------------------------------------------
    // Agent tabs (Agent / Setup)
    // --------------------------------------------
    const agentTabs = document.querySelectorAll('.agent-tabs button');
    const chatPanel = document.getElementById('agentChatLog');
    const setupPanel = document.getElementById('agentSetupPanel');

    agentTabs.forEach(btn => {
      btn.addEventListener('click', () => {
        agentTabs.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const tab = btn.getAttribute('data-tab');
        if (tab === 'chat') {
          chatPanel.style.display = 'flex';
          setupPanel.style.display = 'none';
        } else {
          chatPanel.style.display = 'flex';
          setupPanel.style.display = 'flex';
        }
      });
    });

    // --------------------------------------------
    // DOM references
    // --------------------------------------------
    const agentInput = document.getElementById('agentInput');
    const agentSend = document.getElementById('agentSend');

    const scenePresetLabel = document.getElementById('scenePresetLabel');
    const sceneHardwareLabel = document.getElementById('sceneHardwareLabel');
    const hardwareSelect = document.getElementById('hardwareSelect');
    const hardwareCapabilityHint = document.getElementById('hardwareCapabilityHint');
    const presetSelect = document.getElementById('presetSelect');
    const sceneInterpretation = document.getElementById('sceneInterpretation');

    const neuralWeb = document.getElementById('neuralWeb');
    const workflowContext = document.getElementById('workflowContext');
    const workflowProgressValue = document.getElementById('workflowProgressValue');

    const shotInput = document.getElementById('shotInput');
      const shotLabel = document.getElementById('shotLabel');
      const notesInput = document.getElementById('notesInput');
      const runPresetBtn = document.getElementById('runPresetBtn');
      const runStatus = document.getElementById('runStatus');
      const healthBadges = document.getElementById('healthBadges');
      const runAlert = document.getElementById('runAlert');
      const runAlertText = runAlert?.querySelector('.alert-text');
      const urlKeyWarning = document.getElementById('urlKeyWarning');

    // Console history
    const historyBody = document.getElementById('historyBody');
    const historyFiltersConsole = document.getElementById('historyFiltersConsole');
    const failingTargetsConsole = document.getElementById('failingTargetsConsole');
    const qubitLattice = document.getElementById('qubitLattice');
    const qubitCountDisplay = document.getElementById('qubitCountDisplay');
    const qubitSessionTotal = document.getElementById('qubitSessionTotal');
    const qubitNote = document.getElementById('qubitNote');

    // Experiments page
    const experimentsBody = document.getElementById('experimentsBody');
    const historyFiltersExperiments = document.getElementById('historyFiltersExperiments');
    const refreshExperimentsBtn = document.getElementById('refreshExperimentsBtn');
    const failingTargetsExperiments = document.getElementById('failingTargetsExperiments');

    // Hardware page
    const hardwareMeta = document.getElementById('hardwareMeta');
    const hardwareList = document.getElementById('hardwareList');
    const refreshHardwareBtn = document.getElementById('refreshHardwareBtn');

    // Details page
    const detailsBackBtn = document.getElementById('detailsBackBtn');
    const detailsReloadBtn = document.getElementById('detailsReloadBtn');
    const detailsHeader = document.getElementById('detailsHeader');
    const detailsJson = document.getElementById('detailsJson');
    const detailsInterpretation = document.getElementById('detailsInterpretation');
    const detailsControlProfile = document.getElementById('detailsControlProfile');

    const detailsKpiFidelity = document.getElementById('detailsKpiFidelity');
    const detailsKpiLatency = document.getElementById('detailsKpiLatency');
    const detailsKpiBackaction = document.getElementById('detailsKpiBackaction');
    const detailsKpiShots = document.getElementById('detailsKpiShots');
    const detailsKpiStatus = document.getElementById('detailsKpiStatus');

    // Engineering controls
    const driveBiasInput = document.getElementById('driveBiasInput');
    const driveBiasValue = document.getElementById('driveBiasValue');
    const probeWindowInput = document.getElementById('probeWindowInput');
    const probeWindowValue = document.getElementById('probeWindowValue');
    const feedbackGainInput = document.getElementById('feedbackGainInput');
    const feedbackGainValue = document.getElementById('feedbackGainValue');
    const safetyClampInput = document.getElementById('safetyClampInput');
    const safetyClampValue = document.getElementById('safetyClampValue');
    const spectralShiftInput = document.getElementById('spectralShiftInput');
    const spectralShiftValue = document.getElementById('spectralShiftValue');
    const thermalGuardToggle = document.getElementById('thermalGuardToggle');
    const controlNotesInput = document.getElementById('controlNotesInput');
    const applyControlsBtn = document.getElementById('applyControlsBtn');
    const controlStatus = document.getElementById('controlStatus');
    const controlMeta = document.getElementById('controlMeta');

    // Shor panel
    const shorPanel = document.getElementById('shorPanel');
    const shorBackendChip = document.getElementById('shorBackendChip');
    const shorStatus = document.getElementById('shorStatus');
    const shorRunStatus = document.getElementById('shorRunStatus');
    const shorOutput = document.getElementById('shorOutput');
    const shorRuns = document.getElementById('shorRuns');
    const shorHealthBtn = document.getElementById('shorHealthBtn');
    const shorReloadRunsBtn = document.getElementById('shorReloadRunsBtn');
    const shorOpenLatestBtn = document.getElementById('shorOpenLatestBtn');

    const shorPrimeBits = document.getElementById('shorPrimeBits');
    const shorModulus = document.getElementById('shorModulus');
    const shorExponent = document.getElementById('shorExponent');
    const shorPlainInt = document.getElementById('shorPlainInt');
    const shorPlainText = document.getElementById('shorPlainText');
    const shorCiphertext = document.getElementById('shorCiphertext');
    const shorMethodSelect = document.getElementById('shorMethodSelect');
    const shorBackendSelect = document.getElementById('shorBackendSelect');
    const shorShotsInput = document.getElementById('shorShotsInput');
    const shorIbmBackend = document.getElementById('shorIbmBackend');
    const shorProviderLoader = document.getElementById('shorProviderLoader');
    const shorProviderBackend = document.getElementById('shorProviderBackend');
    const shorLimitNote = document.getElementById('shorLimitNote');
    const shorIbmLabel = document.querySelector('label[for="shorIbmBackend"]');
    const shorProviderLoaderLabel = document.querySelector('label[for="shorProviderLoader"]');
    const shorProviderBackendLabel = document.querySelector('label[for="shorProviderBackend"]');
    const shorGenerateBtn = document.getElementById('shorGenerateBtn');
    const shorEncryptBtn = document.getElementById('shorEncryptBtn');
    const shorDecryptBtn = document.getElementById('shorDecryptBtn');
    const shorEstimateBtn = document.getElementById('shorEstimateBtn');
    const shorFactorBtn = document.getElementById('shorFactorBtn');
    const shorWorkspaceNotes = document.getElementById('shorWorkspaceNotes');
    const shorWorkspaceModulus = document.getElementById('shorWorkspaceModulus');
    const shorWorkspaceExponent = document.getElementById('shorWorkspaceExponent');
    const shorWorkspaceBackend = document.getElementById('shorWorkspaceBackend');
    const shorWorkspacePlaintext = document.getElementById('shorWorkspacePlaintext');
    const shorWorkspaceCiphertext = document.getElementById('shorWorkspaceCiphertext');
    const shorWorkspaceShots = document.getElementById('shorWorkspaceShots');
    const shorWorkspaceStatus = document.getElementById('shorWorkspaceStatus');

    // --------------------------------------------
    // Backend wiring
    // --------------------------------------------
    const SESSION_ID = (() => {
      const key = 'synqc_session_id';
      try {
        const stored = localStorage.getItem(key);
        if (stored) return stored;
        const generated = `synqc-web-${Math.random().toString(36).slice(2, 10)}`;
        localStorage.setItem(key, generated);
        return generated;
      } catch (_) {
        return `synqc-web-${Math.random().toString(36).slice(2, 10)}`;
      }
    })();

    let URL_API_KEYS_ENABLED = false;

    // Better default API base when served via nginx reverse proxy:
    // - If ?api= is set, respect it.
    // - Else if http(s), use same-origin /api.
    // - Else (file://), fallback to localhost backend.
    function getApiBase() {
      const u = new URL(window.location.href);
      const override = u.searchParams.get("api");
      if (override) return override.replace(/\/+$/, "");
      if (location.protocol === "http:" || location.protocol === "https:") {
        return location.origin + "/api";
      }
      return "http://localhost:8001";
    }

    const API_BASE = getApiBase();

    // Supports BOTH:
    //  - X-Api-Key: <value>   (query param: ?api_key=... or ?key=...)
    //  - Authorization: Bearer <value> (query param: ?token=... or ?bearer=...)
    //
    // For dev convenience, query params are persisted to localStorage.
    // For production, avoid shipping secrets in URLs.
    const AUTH = (() => {
      const params = new URLSearchParams(window.location.search);

      const fromBearer = params.get('token') || params.get('bearer');
      const fromApiKey = params.get('api_key') || params.get('key');

      if (fromBearer) {
        try { localStorage.setItem('synqc_bearer_token', fromBearer); } catch (_) {}
      }
      if (fromApiKey) {
        try { localStorage.setItem('synqc_api_key', fromApiKey); } catch (_) {}
      }

      if (fromBearer || fromApiKey) {
        params.delete('token');
        params.delete('bearer');
        params.delete('api_key');
        params.delete('key');
        const newQuery = params.toString();
        const newUrl = `${window.location.pathname}${newQuery ? `?${newQuery}` : ''}${window.location.hash}`;
        if (window.history && window.history.replaceState) {
          window.history.replaceState({}, document.title, newUrl);
        }
        URL_API_KEYS_ENABLED = true;
      }

      let bearer = null;
      let apiKey = null;
      try { bearer = localStorage.getItem('synqc_bearer_token'); } catch (_) {}
      try { apiKey = localStorage.getItem('synqc_api_key'); } catch (_) {}

      return { bearer, apiKey };
    })();
    window.SYNQC_API_KEY = AUTH.apiKey || null;

    function authHeaders() {
      // Prefer Bearer if present
      if (AUTH.bearer) {
        const v = AUTH.bearer.startsWith('Bearer ') ? AUTH.bearer : `Bearer ${AUTH.bearer}`;
        return { 'Authorization': v };
      }
      if (window.SYNQC_API_KEY) return { 'X-Api-Key': window.SYNQC_API_KEY };
      return {};
    }

    const SHOR_LIVE_ALLOW_QUERY_AUTH = Boolean(window.SHOR_LIVE_ALLOW_QUERY_AUTH);
    const SHOR_LIVE_TOKEN_TTL_BUFFER_MS = 5000;
    let SHOR_LIVE_TOKEN_PATH = '/shor/runs/live-token';
    let shorLiveTokenCache = null;

    function shorAuthQuery() {
      // Avoid embedding long-lived credentials in URLs; prefer header auth and negotiated tokens.
      if ((AUTH.bearer || window.SYNQC_API_KEY) && !shorAuthQuery._warned) {
        console.warn('Shor live channels avoid query-string bearer/API keys. Configure a live-token endpoint or set window.SHOR_LIVE_QUERY_TOKEN with a short-lived value if your backend requires URL tokens.');
        shorAuthQuery._warned = true;
      }

      if (!SHOR_LIVE_ALLOW_QUERY_AUTH) return '';

      const params = new URLSearchParams();
      if (window.SHOR_LIVE_QUERY_TOKEN) params.set('live_token', window.SHOR_LIVE_QUERY_TOKEN);
      return params.toString();
    }

    function isShorLiveTokenFresh(tokenObj) {
      if (!tokenObj || (!tokenObj.token && !tokenObj.url)) return false;
      if (!tokenObj.expires_at) return true;
      const exp = new Date(tokenObj.expires_at).getTime();
      if (!Number.isFinite(exp)) return true;
      return exp - Date.now() > SHOR_LIVE_TOKEN_TTL_BUFFER_MS;
    }

    async function fetchShorLiveToken(mode = 'sse') {
      if (!SHOR_LIVE_TOKEN_PATH) return null;
      if (isShorLiveTokenFresh(shorLiveTokenCache)) return shorLiveTokenCache;

      try {
        const res = await apiPost(SHOR_LIVE_TOKEN_PATH, { mode });
        const directUrl = res?.url || res?.stream_url || res?.ws_url || res?.endpoint;
        const token = res?.token || res?.live_token || res?.access_token || res?.signed_token || res?.signed_url || res;
        const expires_at = res?.expires_at || res?.exp || res?.expiry || null;
        if (typeof token === 'string' && token) {
          shorLiveTokenCache = { token, expires_at, url: typeof directUrl === 'string' ? directUrl : null };
          return shorLiveTokenCache;
        }
        if (typeof directUrl === 'string' && directUrl) {
          shorLiveTokenCache = { token: null, expires_at, url: directUrl };
          return shorLiveTokenCache;
        }
      } catch (err) {
        console.warn('Shor live token unavailable', err);
      }

      shorLiveTokenCache = null;
      return null;
    }

    async function shorStreamUrl(path, opts = {}) {
      const base = path.startsWith('http') ? path : `${API_BASE}${path}`;
      const parts = [];
      const qs = shorAuthQuery();
      if (qs) parts.push(qs);
      const token = await fetchShorLiveToken(opts.mode || 'sse');
      if (token?.url) return token.url;
      const tokenValue = typeof token === 'string' ? token : token?.token;
      if (tokenValue) parts.push(`live_token=${encodeURIComponent(tokenValue)}`);
      const final = parts.filter(Boolean).join('&');
      if (!final) return base;
      return `${base}${base.includes('?') ? '&' : '?'}${final}`;
    }

    async function shorWebSocketUrl(path, opts = {}) {
      const full = path.startsWith('http') ? path : `${API_BASE}${path}`;
      try {
        const url = new URL(full);
        url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
        const parts = [];
        const qs = shorAuthQuery();
        if (qs) parts.push(qs);
        const token = await fetchShorLiveToken(opts.mode || 'ws');
        if (token?.url) return token.url;
        const tokenValue = typeof token === 'string' ? token : token?.token;
        if (tokenValue) parts.push(`live_token=${encodeURIComponent(tokenValue)}`);
        const final = parts.filter(Boolean).join('&');
        if (final) {
          const connector = url.search ? '&' : '?';
          url.search = `${url.search || ''}${connector}${final}`;
        }
        return url.toString();
      } catch (_) {
        return null;
      }
    }

    if (URL_API_KEYS_ENABLED && urlKeyWarning) {
      urlKeyWarning.style.display = 'block';
    }

    let MAX_SHOTS_PER_EXPERIMENT = 200000;
    let DEFAULT_SHOT_BUDGET = 2048;

    let lastRun = null;
    let recentRunsCache = [];
    let hardwareTargetsCache = [];
    let healthCache = null;

    let controlProfileCache = null;

    const shorUrlParams = new URLSearchParams(window.location.search);
    SHOR_LIVE_TOKEN_PATH = shorUrlParams.get('shor_live_token_path') || SHOR_LIVE_TOKEN_PATH;
    const SHOR_STREAM_PATH = shorUrlParams.get('shor_stream') || '/shor/runs/stream';
    const SHOR_WS_PATH = shorUrlParams.get('shor_ws') || '/shor/runs/ws';

    let shorRunsCache = [];
    let shorHealthCache = null;
    let shorRunPollTimer = null;
    let shorRunPollInFlight = false;
    let shorRunPollPending = false;
    let shorRunEventSource = null;
    let shorRunSocket = null;
    const SHOR_RUN_POLL_INTERVAL_MS = 6000;
    let SHOR_N_LIMITS = {
      auto: { max: 32000, label: 'auto/aer guardrail ~32,000' },
      aer: { max: 32000, label: 'auto/aer guardrail ~32,000' },
      ibm: { max: 4096, label: 'IBM Runtime guardrail ~4,096' },
      custom: { max: 4096, label: 'custom provider guardrail ~4,096' },
      classical: { max: 5000000, label: 'classical guardrail ~5,000,000' },
    };

    let activeWorkflowTrace = [];
    let workflowTimers = [];
    let pendingWorkflowTrace = null;
    let workflowRenderRaf = null;
    let lastWorkflowSignature = '';
    let neuralNodePool = [];
    let neuralLinkPool = [];
    let refreshTimer = null;
    let refreshResolvers = [];
    const historyRowPool = [];
    const experimentsRowPool = [];

    let selectedExperimentId = null;
    let qubitDemoInterval = null;
    let qubitDemoCount = 1;
    let latestQubitCount = null;
    let sessionQubitTotal = 0;
    const latencySamples = [];

    function updateLatencyOverlay(durationMs) {
      const valueEl = document.getElementById('latencyValue');
      if (!valueEl) return;
      if (typeof durationMs !== 'number' || Number.isNaN(durationMs)) {
        valueEl.textContent = '--';
        return;
      }
      latencySamples.push(durationMs);
      if (latencySamples.length > 20) latencySamples.shift();
      const avg = latencySamples.reduce((sum, v) => sum + v, 0) / latencySamples.length;
      valueEl.textContent = `${Math.round(durationMs)}ms (avg ${Math.round(avg)}ms)`;
    }

    function clearChildren(el) {
      if (!el) return;
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function setRunStatus(text) {
      runStatus.textContent = text;
      if (runAlert) {
        runAlert.style.display = 'none';
        if (runAlertText) runAlertText.textContent = '';
      }
    }

    function showRunAlert(message) {
      if (!message) return;
      if (!runAlert) return;
      if (runAlertText) runAlertText.textContent = message;
      runAlert.style.display = 'flex';
    }

    function renderHealthSummary(health) {
      if (healthBadges) clearChildren(healthBadges);

      if (!health) {
        if (healthBadges) {
          const chip = document.createElement('div');
          chip.className = 'status-badge';
          chip.dataset.state = 'bad';
          chip.textContent = 'Backend disconnected';
          healthBadges.appendChild(chip);
        }
        if (hardwareMeta) {
          hardwareMeta.textContent = 'Backend capability not loaded yet; check /health.';
        }
        return;
      }

      const addBadge = (label, state = 'ok') => {
        if (!healthBadges) return;
        const chip = document.createElement('div');
        chip.className = 'status-badge';
        chip.dataset.state = state;
        chip.textContent = label;
        healthBadges.appendChild(chip);
      };

      const version = health.version || 'unknown';
      addBadge(`Version ${version}`);

      const targetCount = (typeof health.visible_target_count === 'number')
        ? `${health.visible_target_count} targets visible`
        : 'Target discovery pending';
      addBadge(targetCount, health.visible_target_count === 0 ? 'warn' : 'ok');

      const queueConn = health.queue_connectivity || {};
      const queueStats = health.queue || {};
      const queueBackend = queueConn.backend || queueStats.backend || 'queue';
      const depth = (queueStats && queueStats.queued != null) ? queueStats.queued : queueConn.queue_depth;
      const queueState = queueConn.connected === false ? 'bad' : 'ok';
      const queueLabel = queueConn.connected === false
        ? `${queueBackend}: offline`
        : `${queueBackend}: depth ${depth ?? 0}`;
      addBadge(queueLabel, queueState);

      const persistence = health.persistence || {};
      const persistOk = persistence.persist_ok !== false;
      addBadge(persistOk ? 'Persistence ok' : 'Persistence degraded', persistOk ? 'ok' : 'warn');

      const providerMetrics = health.provider_metrics || {};
      const providerTotals = providerMetrics.totals || {};
      const providerFailures = providerTotals.failure || 0;
      const providerLabel = providerFailures > 0
        ? `Providers: ${providerFailures} failures${(providerMetrics.failing_targets || []).length ? ` (${(providerMetrics.failing_targets || []).join(', ')})` : ''}`
        : 'Providers stable';
      addBadge(providerLabel, providerFailures > 0 ? 'warn' : 'ok');

      if (health.redis !== undefined) {
        addBadge(health.redis ? 'Redis reachable' : 'Redis unreachable', health.redis ? 'ok' : 'bad');
      }

      if (health.require_api_key) {
        const hasKey = Boolean(AUTH.bearer || window.SYNQC_API_KEY);
        addBadge(hasKey ? 'API key supplied' : 'API key required', hasKey ? 'ok' : 'warn');
        if (!hasKey) {
          showRunAlert('Backend requires an API key. Add ?api_key=... or ?token=... to seed credentials.');
        }
      }

      if (health.server_time) {
        addBadge(`Server ${new Date(health.server_time).toLocaleString()}`);
      }

      if (hardwareMeta) {
        const parts = [`Backend: ${API_BASE}`, `version=${version}`];
        if (typeof health.visible_target_count === 'number') parts.push(`targets=${health.visible_target_count}`);
        if (typeof health.allow_remote_hardware === 'boolean') parts.push(`allow_remote_hardware=${health.allow_remote_hardware}`);
        if (typeof health.max_shots_per_experiment === 'number') parts.push(`max_shots_per_experiment=${health.max_shots_per_experiment.toLocaleString()}`);
        if (depth != null) parts.push(`queue_depth=${depth}`);
        if (providerFailures > 0) parts.push(`provider_failures=${providerFailures}`);
        if (persistence.persist_ok === false) parts.push('persistence=degraded');
        hardwareMeta.textContent = parts.join(' · ');
      }
    }

    async function synqcApiFetch(path, opts = {}) {
      const options = {...opts};
      options.headers = {...(options.headers || {})};

      if (window.SYNQC_API_KEY) options.headers["X-Api-Key"] = window.SYNQC_API_KEY;
      if (AUTH.bearer) options.headers["Authorization"] = `Bearer ${AUTH.bearer}`;

      options.credentials = "include";
      const start = performance.now();
      let res = await fetch(`${API_BASE}${path}`, options);
      updateLatencyOverlay(performance.now() - start);

      return res;
    }

    async function apiGet(path) {
      const res = await synqcApiFetch(path, {
        method: 'GET',
        headers: authHeaders(),
      });
      if (!res.ok) {
        let detail = null;
        try { detail = await res.json(); } catch (_) {}
        const payload = detail?.detail || detail || {};
        const msg = payload.error_message || payload.message || `HTTP ${res.status}`;
        const err = new Error(msg);
        err.response = payload;
        throw err;
      }
      return await res.json();
    }

    async function apiPost(path, payload) {
      const res = await synqcApiFetch(path, {
        method: 'POST',
        headers: Object.assign(
          { 'Content-Type': 'application/json' },
          authHeaders()
        ),
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        // Try to bubble up useful backend details (nice for your UI alerts)
        let detail = null;
        try { detail = await res.json(); } catch (_) {}
        const payload = detail?.detail || detail || {};
        const msg = payload.error_message || payload.message || `HTTP ${res.status}`;
        const err = new Error(msg);
        err.response = payload;
        throw err;
      }
      return await res.json();
    }

    // --------------------------------------------
    // Shor control surface
    // --------------------------------------------
    function shorParseIntField(value, name) {
      const v = String(value ?? '').trim();
      if (!v) return null;
      if (!/^-?\d+$/.test(v)) throw new Error(`${name} must be an integer`);
      const n = Number(v);
      if (!Number.isFinite(n) || !Number.isSafeInteger(n)) throw new Error(`${name} is not a safe integer`);
      return n;
    }

    function shorHasHardwareAuth() {
      return Boolean(AUTH.bearer || window.SYNQC_API_KEY);
    }

    function setShorWorkspaceStatus(text, state = 'idle') {
      if (!shorWorkspaceStatus) return;
      shorWorkspaceStatus.textContent = text;
      shorWorkspaceStatus.dataset.state = state;
    }

    function setShorBusy(isBusy) {
      if (!shorPanel) return;
      shorPanel.classList.toggle('shor-busy', isBusy);
      shorPanel.querySelectorAll('button, input, select, textarea').forEach((el) => {
        if (el.matches('[data-shor-keep-enabled]') || el.readOnly) return;
        el.disabled = isBusy;
      });
      const base = (shorRunStatus?.textContent || '').trim();
      setShorWorkspaceStatus(isBusy ? base || 'Running Shor request…' : base || 'Ready for input', isBusy ? 'running' : (shorWorkspaceStatus?.dataset.state || 'idle'));
    }

    function shorLog(obj) {
      if (!shorOutput) return;
      try {
        shorOutput.textContent = JSON.stringify(obj, null, 2);
      } catch (e) {
        shorOutput.textContent = String(obj);
      }
      shorOutput.scrollTop = 0;
      updateShorWorkspaceSnapshot();
    }

    function applyShorGuardrailsFromHealth(health) {
      const guardrails = health?.limits?.guardrails;
      const maxBits = Number.isFinite(health?.limits?.max_n_bits) ? Number(health.limits.max_n_bits) : null;
      if (!guardrails && !maxBits) return;

      const merged = { ...SHOR_N_LIMITS };
      if (guardrails && typeof guardrails === 'object') {
        Object.entries(guardrails).forEach(([mode, info]) => {
          if (!info || typeof info !== 'object') return;
          const max = Number(info.max);
          const label = info.label || merged[mode]?.label || `${mode} guardrail`;
          if (Number.isFinite(max)) {
            merged[mode] = { max, label };
          } else if (merged[mode]) {
            merged[mode] = { ...merged[mode], label };
          } else {
            merged[mode] = { label };
          }
        });
      }

      const capFromBits = Number.isFinite(maxBits) ? (1 << maxBits) - 1 : null;
      if (Number.isFinite(capFromBits)) {
        Object.entries(merged).forEach(([mode, info]) => {
          const max = Number(info?.max);
          if (Number.isFinite(max)) {
            merged[mode] = { ...info, max: Math.min(max, capFromBits) };
          }
        });
      }

      SHOR_N_LIMITS = merged;
      updateShorLimitNote();
    }

    function shorLimitForMode(mode, method) {
      if (method === 'classical') return SHOR_N_LIMITS.classical;
      return SHOR_N_LIMITS[mode] || SHOR_N_LIMITS.auto;
    }

    function enforceShorLimit(N, opts = {}) {
      const { backend_mode, method } = opts;
      const limit = shorLimitForMode(backend_mode, method);
      if (limit?.max && Math.abs(N) > limit.max) {
        throw new Error(`N exceeds ${limit.label}. Current N=${Number(N).toLocaleString()}.`);
      }
    }

    function updateShorLimitNote() {
      if (!shorLimitNote) return;
      const mode = shorBackendSelect?.value || 'auto';
      const method = shorMethodSelect?.value || 'auto';
      const limit = shorLimitForMode(mode, method);
      const classicalLabel = SHOR_N_LIMITS.classical?.label || 'classical guardrail';
      const label = limit?.label || 'quantum guardrail';
      const suffix = method === 'classical' ? '' : `; classical path ${classicalLabel}`;
      shorLimitNote.textContent = `Guardrails: ${label}${suffix}.`;
    }

    function describeShorRunPhase(run) {
      if (!run) return { text: 'Waiting for input…', state: 'idle' };
      const statusRaw = (run.status || run.state || run.phase || '').toString().toLowerCase();
      const phaseRaw = (run.phase || run.stage || '').toString().toLowerCase();
      const runId = run.run_id || run.id || run.uuid || '';
      const label = runId ? `Run ${runId}` : 'Latest run';
      const backend = run.provider_backend_name || run.backend_name || run.backend_mode || run.backend || 'backend';
      const runtimeMs = Number.isFinite(run.runtime_ms) ? Number(run.runtime_ms) : null;

      const failed = run.ok === false || statusRaw === 'fail' || statusRaw === 'failed' || statusRaw === 'error';
      if (failed) return { text: `${label} failed on ${backend}.`, state: 'fail' };

      const queuedStates = ['queued', 'pending', 'submitted', 'waiting', 'created'];
      const runningStates = ['running', 'executing', 'progress', 'active'];
      const completedStates = ['completed', 'done', 'success', 'ok', 'finished'];

      if (queuedStates.includes(statusRaw) || queuedStates.includes(phaseRaw)) {
        return { text: `${label} queued on ${backend}…`, state: 'queued' };
      }

      if (runningStates.includes(statusRaw) || runningStates.includes(phaseRaw)) {
        const runtimeLabel = runtimeMs ? ` · ${Math.round(runtimeMs)} ms so far` : '';
        return { text: `${label} running on ${backend}${runtimeLabel}…`, state: 'running' };
      }

      if (completedStates.includes(statusRaw) || run.ok === true) {
        const runtimeLabel = runtimeMs ? ` in ${Math.round(runtimeMs)} ms` : '';
        return { text: `${label} completed${runtimeLabel}.`, state: 'ok' };
      }

      if (statusRaw) return { text: `${label} status: ${statusRaw}.`, state: 'queued' };
      return { text: `${label} ready.`, state: 'idle' };
    }

    function latestActiveShorRun(runs) {
      if (!Array.isArray(runs) || runs.length === 0) return null;
      const queuedOrRunning = runs.find((r) => {
        const statusRaw = (r.status || r.state || r.phase || '').toString().toLowerCase();
        const phaseRaw = (r.phase || r.stage || '').toString().toLowerCase();
        const queuedStates = ['queued', 'pending', 'submitted', 'waiting', 'created'];
        const runningStates = ['running', 'executing', 'progress', 'active'];
        return queuedStates.includes(statusRaw) || queuedStates.includes(phaseRaw) || runningStates.includes(statusRaw) || runningStates.includes(phaseRaw);
      });
      return queuedOrRunning || runs[0];
    }

    function updateShorWorkspaceStatusFromRuns(runs) {
      const desc = describeShorRunPhase(latestActiveShorRun(runs));
      updateShorWorkspaceSnapshot(desc);
    }

    function updateShorBackendFields() {
      if (!shorBackendSelect) return;
      const mode = shorBackendSelect.value;
      const showIbm = mode === 'ibm';
      const showCustom = mode === 'custom';
      const hasAuth = shorHasHardwareAuth();

      [shorIbmLabel, shorIbmBackend].forEach((el) => { if (el) el.style.display = showIbm ? '' : 'none'; });
      [shorProviderLoaderLabel, shorProviderLoader, shorProviderBackendLabel, shorProviderBackend].forEach((el) => {
        if (el) el.style.display = showCustom ? '' : 'none';
      });

      if (shorBackendChip) {
        if (mode === 'aer') {
          shorBackendChip.textContent = 'Backend: aer (local simulator)';
          shorBackendChip.dataset.state = '';
        } else if (mode === 'ibm') {
          shorBackendChip.textContent = hasAuth
            ? `Backend: IBM Runtime${shorIbmBackend?.value ? ` (${shorIbmBackend.value})` : ''}`
            : 'Backend: IBM Runtime (token required)';
          shorBackendChip.dataset.state = hasAuth ? '' : 'warn';
        } else {
          shorBackendChip.textContent = hasAuth
            ? `Backend: custom provider${shorProviderBackend?.value ? ` (${shorProviderBackend.value})` : ''}`
            : 'Backend: custom provider (token required)';
          shorBackendChip.dataset.state = hasAuth ? 'warn' : 'bad';
        }
      }

      updateShorLimitNote();
      updateShorWorkspaceSnapshot();
    }

    function updateShorWorkspaceSnapshot(statusOverride) {
      if (!shorWorkspaceModulus) return;
      const N = (shorModulus?.value || '').trim();
      const e = (shorExponent?.value || '').trim();
      const backend_mode = (shorBackendSelect?.value || 'aer').toLowerCase();
      const method = (shorMethodSelect?.value || 'auto').toLowerCase();
      const shots = (shorShotsInput?.value || '').trim();
      const plaintext_text = (shorPlainText?.value || '').trim();
      const plaintext_int = (shorPlainInt?.value || '').trim();
      const ciphertext = (shorCiphertext?.value || '').trim();
      const guardrail = shorLimitNote?.textContent || '';

      shorWorkspaceModulus.textContent = N || '—';
      shorWorkspaceExponent.textContent = e || '—';
      shorWorkspaceBackend.textContent = `${backend_mode} • ${method}`;
      shorWorkspacePlaintext.textContent = plaintext_text
        ? `text: "${plaintext_text.slice(0, 90)}"`
        : plaintext_int || '—';
      shorWorkspaceCiphertext.textContent = ciphertext || '—';
      shorWorkspaceShots.textContent = `${shots || 'auto'} | ${guardrail}`;
      if (statusOverride) {
        setShorWorkspaceStatus(statusOverride.text, statusOverride.state);
      } else if (shorWorkspaceStatus) {
        const current = (shorWorkspaceStatus.textContent || '').trim();
        const status = (shorRunStatus?.textContent || '').trim();
        const derived = (current && shorWorkspaceStatus.dataset.state && shorWorkspaceStatus.dataset.state !== 'idle')
          ? current
          : status || 'Ready for input';
        setShorWorkspaceStatus(derived, shorWorkspaceStatus.dataset.state || 'idle');
      }
    }

    function collectShorBackendOptions() {
      const backend_mode = shorBackendSelect?.value || 'aer';
      const shots = shorParseIntField(shorShotsInput?.value, 'shots') ?? 1024;
      const ibm_backend_name = (shorIbmBackend?.value || '').trim() || null;
      const provider_loader = (shorProviderLoader?.value || '').trim() || null;
      const provider_backend_name = (shorProviderBackend?.value || '').trim() || null;

      if ((backend_mode === 'ibm' || backend_mode === 'custom') && !shorHasHardwareAuth()) {
        throw new Error('Hardware modes require a bearer token (synqc_bearer_token/api_key).');
      }
      if (backend_mode === 'custom' && !provider_backend_name) {
        throw new Error('Provide a provider backend name for custom mode.');
      }

      return { backend_mode, shots, ibm_backend_name, provider_loader, provider_backend_name };
    }

    function renderShorRuns(runs) {
      if (!shorRuns) return;
      shorRuns.innerHTML = '';
      if (!Array.isArray(runs) || runs.length === 0) {
        const hint = document.createElement('div');
        hint.className = 'shor-help';
        hint.textContent = 'No Shor runs recorded yet.';
        shorRuns.appendChild(hint);
        return;
      }

      runs.forEach((r) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `shor-run ${r.ok === false ? 'shor-run--bad' : ''}`;
        const ts = r.ts_utc || r.created_at || '';
        btn.innerHTML = `
          <div class="shor-run__top">
            <span>${r.kind || 'run'}</span>
            <span>${String(ts).split('T')[1] || ts || ''}</span>
          </div>
          <div class="shor-run__bot">
            <span class="shor-run__status">${r.ok === false ? 'fail' : 'ok'}</span>
            <span>${Math.round(r.runtime_ms || 0)} ms</span>
          </div>`;
        btn.addEventListener('click', () => openShorRun(r.run_id || r.id));
        shorRuns.appendChild(btn);
      });
    }

    async function refreshShorRuns(options = {}) {
      if (!shorRunStatus) return;
      const { silent } = options;
      if (shorRunPollInFlight) {
        shorRunPollPending = true;
        return;
      }
      if (!silent) shorRunStatus.textContent = 'Loading runs from /shor/runs…';
      shorRunPollInFlight = true;
      try {
        const data = await apiGet('/shor/runs?limit=12');
        shorRunsCache = data?.runs || [];
        renderShorRuns(shorRunsCache);
        renderExperimentsTable();
        updateShorWorkspaceStatusFromRuns(shorRunsCache);
        shorRunStatus.textContent = `Runs loaded (${shorRunsCache.length || 0}).`;
      } catch (err) {
        if (!silent) shorRunStatus.textContent = 'Runs unavailable (/shor/runs).';
        shorLog({ error: err.message });
      } finally {
        shorRunPollInFlight = false;
        if (shorRunPollPending) {
          shorRunPollPending = false;
          refreshShorRuns({ silent: true });
        }
      }
    }

    function startShorRunPolling() {
      if (shorRunPollTimer) clearInterval(shorRunPollTimer);
      shorRunPollTimer = setInterval(() => refreshShorRuns({ silent: true }), SHOR_RUN_POLL_INTERVAL_MS);
      if (!startShorRunPolling._visibilityHooked) {
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') refreshShorRuns({ silent: true });
        });
        startShorRunPolling._visibilityHooked = true;
      }
    }

    function stopShorRunPolling() {
      if (shorRunPollTimer) clearInterval(shorRunPollTimer);
      shorRunPollTimer = null;
    }

    function applyLiveShorRunPayload(payload) {
      const detail = payload?.run || payload?.detail || payload;
      if (!detail || typeof detail !== 'object') return;
      const id = detail.run_id || detail.id || detail.uuid;
      if (!id) return;

      const idx = shorRunsCache.findIndex((r) => (r.run_id || r.id || r.uuid) === id);
      if (idx >= 0) {
        shorRunsCache[idx] = { ...shorRunsCache[idx], ...detail };
      } else {
        shorRunsCache.unshift(detail);
        shorRunsCache = shorRunsCache.slice(0, 12);
      }

      renderShorRuns(shorRunsCache);
      renderExperimentsTable();
      updateShorWorkspaceStatusFromRuns(shorRunsCache);
    }

    function stopShorLiveChannel() {
      if (shorRunEventSource) {
        try { shorRunEventSource.close(); } catch (_) {}
      }
      if (shorRunSocket) {
        try { shorRunSocket.close(); } catch (_) {}
      }
      shorRunEventSource = null;
      shorRunSocket = null;
    }

    async function startShorLiveChannel() {
      stopShorLiveChannel();

      const onLiveError = (label) => {
        if (shorRunStatus && !shorRunPollInFlight) {
          shorRunStatus.textContent = `${label}; falling back to polling.`;
        }
        startShorRunPolling();
      };

      const onLiveConnected = (mode) => {
        if (shorRunStatus) shorRunStatus.textContent = `Live ${mode} updates engaged.`;
        stopShorRunPolling();
      };

      if (window.EventSource) {
        try {
          const streamUrl = await shorStreamUrl(SHOR_STREAM_PATH, { mode: 'sse' });
          const es = new EventSource(streamUrl, { withCredentials: true });
          shorRunEventSource = es;
          es.onmessage = (evt) => {
            try {
              const parsed = JSON.parse(evt.data || '{}');
              applyLiveShorRunPayload(parsed);
            } catch (_) {}
          };
          es.onerror = () => {
            stopShorLiveChannel();
            onLiveError('Shor live stream unavailable');
          };
          onLiveConnected('SSE');
          return;
        } catch (err) {
          stopShorLiveChannel();
          onLiveError('Shor live stream unavailable');
        }
      }

      if ('WebSocket' in window) {
        try {
          const wsUrl = await shorWebSocketUrl(SHOR_WS_PATH, { mode: 'ws' });
          if (!wsUrl) throw new Error('WebSocket URL invalid');
          const sock = new WebSocket(wsUrl);
          shorRunSocket = sock;
          sock.onopen = () => onLiveConnected('WebSocket');
          sock.onmessage = (evt) => {
            try {
              const parsed = JSON.parse(evt.data || '{}');
              applyLiveShorRunPayload(parsed);
            } catch (_) {}
          };
          sock.onerror = () => {
            stopShorLiveChannel();
            onLiveError('Shor WebSocket unavailable');
          };
          sock.onclose = () => {
            stopShorLiveChannel();
            startShorRunPolling();
          };
          return;
        } catch (err) {
          stopShorLiveChannel();
          onLiveError('Shor WebSocket unavailable');
        }
      }

      startShorRunPolling();
    }

    async function openShorRun(runId) {
      if (!runId) return;
      shorRunStatus.textContent = `Loading run ${runId}…`;
      try {
        const data = await apiGet(`/shor/runs/${encodeURIComponent(runId)}`);
        shorRunStatus.textContent = `Run ${runId} loaded.`;
        shorLog({ action: 'run_detail', ...data });
        const detail = data?.run || data?.detail || data;
        if (detail && typeof detail === 'object') {
          updateShorWorkspaceSnapshot(describeShorRunPhase(detail));
        }
      } catch (err) {
        shorRunStatus.textContent = `Run ${runId} unavailable.`;
        shorLog({ error: err.message });
      }
    }

    async function refreshShorHealth() {
      if (!shorStatus) return;
      shorStatus.textContent = 'Checking /shor/health…';
      try {
        const h = await apiGet('/shor/health');
        shorHealthCache = h;
        shorStatus.innerHTML = `<strong>Backend OK</strong> (${h.feature || 'shor_rsa_demo'})`;
        if (shorBackendChip) shorBackendChip.dataset.state = '';
        applyShorGuardrailsFromHealth(h);
        updateShorBackendFields();
      } catch (err) {
        shorStatus.textContent = 'Backend unavailable (/shor/health).';
        if (shorBackendChip) shorBackendChip.dataset.state = 'bad';
        shorLog({ error: err.message });
      }
    }

    async function shorGenerate() {
      setShorBusy(true);
      try {
        const bits = shorParseIntField(shorPrimeBits?.value, 'Prime bits') ?? 12;
        const e = shorParseIntField(shorExponent?.value, 'e') ?? 65537;
        const data = await apiPost('/shor/rsa/generate', { bits, e });
        if (shorModulus) shorModulus.value = String(data.N);
        if (shorExponent) shorExponent.value = String(data.e);
        shorRunStatus.textContent = 'Generated demo RSA key.';
        shorLog({ action: 'rsa_generate', ...data });
        refreshShorRuns();
      } catch (err) {
        shorRunStatus.textContent = err.message;
        shorLog({ error: err.message });
      } finally {
        setShorBusy(false);
      }
    }

    async function shorEncrypt() {
      setShorBusy(true);
      try {
        const N = shorParseIntField(shorModulus?.value, 'N');
        const e = shorParseIntField(shorExponent?.value, 'e');
        if (N === null || e === null) throw new Error('Provide N and e.');
        const plaintext_int = shorParseIntField(shorPlainInt?.value, 'plaintext_int');
        const plaintext_text = (shorPlainText?.value || '').trim();
        const body = { N, e };
        if (plaintext_int !== null) body.plaintext_int = plaintext_int;
        else if (plaintext_text) body.plaintext_text = plaintext_text;
        else throw new Error('Provide plaintext_int or plaintext_text.');
        const data = await apiPost('/shor/rsa/encrypt', body);
        if (shorCiphertext) shorCiphertext.value = String(data.ciphertext_int);
        shorRunStatus.textContent = 'Encrypted payload.';
        shorLog({ action: 'rsa_encrypt', ...data });
        refreshShorRuns();
      } catch (err) {
        shorRunStatus.textContent = err.message;
        shorLog({ error: err.message });
      } finally {
        setShorBusy(false);
      }
    }

    async function shorDecrypt() {
      setShorBusy(true);
      try {
        const N = shorParseIntField(shorModulus?.value, 'N');
        const e = shorParseIntField(shorExponent?.value, 'e');
        const ciphertext_int = shorParseIntField(shorCiphertext?.value, 'ciphertext_int');
        if (N === null || e === null || ciphertext_int === null) throw new Error('Provide N, e, and ciphertext.');
        const opts = collectShorBackendOptions();
        const method = shorMethodSelect?.value || 'auto';
        enforceShorLimit(N, { backend_mode: opts.backend_mode, method });
        const data = await apiPost('/shor/rsa/decrypt', { N, e, ciphertext_int, method, ...opts });
        shorRunStatus.textContent = `Decrypt complete (${data.method_used || method}).`;
        shorLog({ action: 'rsa_decrypt', ...data });
        refreshShorRuns();
      } catch (err) {
        shorRunStatus.textContent = err.message;
        shorLog({ error: err.message });
      } finally {
        setShorBusy(false);
      }
    }

    async function shorFactor() {
      setShorBusy(true);
      try {
        const N = shorParseIntField(shorModulus?.value, 'N');
        if (N === null) throw new Error('Provide N to factor.');
        const opts = collectShorBackendOptions();
        const method = shorMethodSelect?.value || 'auto';
        enforceShorLimit(N, { backend_mode: opts.backend_mode, method });
        const data = await apiPost('/shor/factor', { N, method, ...opts });
        shorRunStatus.textContent = `Factorization dispatched (${data.method_used || method}).`;
        shorLog({ action: 'factor', ...data });
        refreshShorRuns();
      } catch (err) {
        shorRunStatus.textContent = err.message;
        shorLog({ error: err.message });
      } finally {
        setShorBusy(false);
      }
    }

    async function shorEstimate() {
      setShorBusy(true);
      try {
        const N = shorParseIntField(shorModulus?.value, 'N');
        if (N === null) throw new Error('Provide N to estimate.');
        const backend_mode = shorBackendSelect?.value || 'auto';
        const method = shorMethodSelect?.value || 'auto';
        enforceShorLimit(N, { backend_mode, method });
        const data = await apiPost('/shor/estimate', { N });
        shorRunStatus.textContent = 'Resource estimate ready.';
        shorLog({ action: 'estimate', ...data });
      } catch (err) {
        shorRunStatus.textContent = err.message;
        shorLog({ error: err.message });
      } finally {
        setShorBusy(false);
      }
    }

    function initShorPanel() {
      if (!shorPanel) return;
      updateShorBackendFields();
      refreshShorHealth();
      refreshShorRuns();

      [shorBackendSelect, shorIbmBackend, shorProviderLoader, shorProviderBackend, shorMethodSelect].forEach((el) => {
        if (el) el.addEventListener('input', updateShorBackendFields);
        if (el) el.addEventListener('change', updateShorBackendFields);
      });

      if (shorHealthBtn) shorHealthBtn.addEventListener('click', refreshShorHealth);
      if (shorReloadRunsBtn) shorReloadRunsBtn.addEventListener('click', refreshShorRuns);
      if (shorOpenLatestBtn) shorOpenLatestBtn.addEventListener('click', () => {
        const latest = shorRunsCache?.[0];
        if (latest) openShorRun(latest.run_id || latest.id);
      });
      if (shorGenerateBtn) shorGenerateBtn.addEventListener('click', shorGenerate);
      if (shorEncryptBtn) shorEncryptBtn.addEventListener('click', shorEncrypt);
      if (shorDecryptBtn) shorDecryptBtn.addEventListener('click', shorDecrypt);
      if (shorFactorBtn) shorFactorBtn.addEventListener('click', shorFactor);
      if (shorEstimateBtn) shorEstimateBtn.addEventListener('click', shorEstimate);
      [
        shorPrimeBits,
        shorModulus,
        shorExponent,
        shorPlainInt,
        shorPlainText,
        shorCiphertext,
        shorShotsInput,
        shorWorkspaceNotes,
      ].forEach((el) => {
        if (el) {
          el.addEventListener('input', updateShorWorkspaceSnapshot);
          el.addEventListener('change', updateShorWorkspaceSnapshot);
        }
      });

      updateShorWorkspaceSnapshot();
      startShorRunPolling();
      startShorLiveChannel();
    }

    function fmtTimeFromEpochSeconds(epochSec) {
      if (!Number.isFinite(epochSec)) return '—';
      const d = new Date(epochSec * 1000);
      if (Number.isNaN(d.getTime())) return '—';
      return d.toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function presetLabel(preset) {
      if (preset === 'hello_quantum_sim') return 'Hello Quantum (Sim)';
      if (preset === 'health') return 'Health (T1/T2/RB)';
      if (preset === 'latency') return 'Latency probe';
      if (preset === 'grover_demo') return 'Grover search (Qiskit/Aer)';
      if (preset === 'backend_compare') return 'Backend compare';
      if (preset === 'grover_demo') return 'Grover energy search';
      if (preset === 'dpd_demo') return 'DPD demo';
      if (preset === 'shor') return 'Shor factoring';
      return preset;
    }

    function statusLabel(status) {
      if (status === 'ok') return 'OK';
      if (status === 'warn') return 'WARN';
      if (status === 'fail') return 'FAIL';
      return String(status || '').toUpperCase() || 'OK';
    }

    function statusClass(status) {
      if (status === 'fail') return 'status-fail';
      if (status === 'warn') return 'status-warn';
      return 'status-ok';
    }

    function setKpiClass(el, status) {
      el.classList.remove('kpi-good', 'kpi-warn', 'kpi-bad');
      if (status === 'fail') el.classList.add('kpi-bad');
      else if (status === 'warn') el.classList.add('kpi-warn');
      else el.classList.add('kpi-good');
    }

    function clamp01(x) {
      if (!Number.isFinite(x)) return 0;
      return Math.max(0, Math.min(1, x));
    }

    function hardwareNameForId(id) {
      // Prefer cache from /hardware/targets
      const found = (hardwareTargetsCache || []).find(t => t.id === id);
      if (found && found.name) return found.name;

      // Fall back to current select option
      const opt = Array.from(hardwareSelect.options || []).find(o => o.value === id);
      return opt ? opt.textContent : id;
    }

    function hardwareCapabilitiesForId(id) {
      const found = (hardwareTargetsCache || []).find(t => t.id === id);
      return found?.capabilities;
    }

    function summarizeCapabilities(cap) {
      if (!cap) return null;
      const parts = [];
      if (Number.isFinite(cap.max_shots)) parts.push(`max ${Number(cap.max_shots).toLocaleString()} shots`);
      if (cap.queue_behavior) parts.push(`queue=${cap.queue_behavior}`);
      if (Array.isArray(cap.supported_gates) && cap.supported_gates.length) {
        const gates = cap.supported_gates.slice(0, 6).join(', ');
        parts.push(`gates: ${gates}${cap.supported_gates.length > 6 ? '…' : ''}`);
      }
      if (cap.notes) parts.push(cap.notes);
      return parts.join(' · ');
    }

    function fmtNs(ns) {
      return `${Number(ns || 0).toLocaleString()} ns`;
    }

    function fmtDeg(deg) {
      const n = Number(deg || 0);
      return `${n > 0 ? '+' : ''}${n.toFixed(0)}°`;
    }

    function summarizeControlProfile(profile) {
      if (!profile) return '—';
      if (profile.shor) return profile.shor;
      const drive = Number(profile.drive_bias ?? 1).toFixed(2);
      const gain = Number(profile.feedback_gain ?? 0).toFixed(2);
      const clamp = `${Number(profile.safety_clamp_ns ?? 0).toLocaleString()} ns`;
      const guard = profile.thermal_guard_enabled === false ? 'guards off' : 'guards on';
      return `drive ${drive} · gain ${gain} · clamp ${clamp} · ${guard}`;
    }

    function setSpectralShift(deg) {
      if (!Number.isFinite(deg)) return;
      const clamped = Math.max(-180, Math.min(deg, 180));
      document.documentElement.style.setProperty('--spectral-shift', `${clamped}deg`);
      if (spectralShiftValue) spectralShiftValue.textContent = fmtDeg(clamped);
      try { localStorage.setItem('synqc_spectral_shift', String(clamped)); } catch (_) { /* ignore */ }
    }

    function hydrateSpectralShiftFromStorage() {
      let stored = null;
      try { stored = Number(localStorage.getItem('synqc_spectral_shift')); } catch (_) { /* ignore */ }
      if (Number.isFinite(stored)) {
        if (spectralShiftInput) spectralShiftInput.value = String(stored);
        setSpectralShift(stored);
      } else if (spectralShiftInput) {
        setSpectralShift(Number(spectralShiftInput.value || 0));
      }
    }

    function applyControlProfileToUi(profile) {
      if (!profile) return;
      controlProfileCache = profile;
      if (driveBiasInput) {
        driveBiasInput.value = profile.drive_bias ?? 1.0;
        driveBiasValue.textContent = `${Number(profile.drive_bias ?? 1).toFixed(2)}x`;
      }
      if (probeWindowInput) {
        probeWindowInput.value = profile.probe_window_ns ?? 120;
        probeWindowValue.textContent = fmtNs(profile.probe_window_ns ?? 120);
      }
      if (feedbackGainInput) {
        feedbackGainInput.value = profile.feedback_gain ?? 0.35;
        feedbackGainValue.textContent = Number(profile.feedback_gain ?? 0).toFixed(2);
      }
      if (safetyClampInput) {
        safetyClampInput.value = profile.safety_clamp_ns ?? 600;
        safetyClampValue.textContent = fmtNs(profile.safety_clamp_ns ?? 0);
      }
      if (thermalGuardToggle) thermalGuardToggle.checked = !!profile.thermal_guard_enabled;
      if (controlNotesInput) controlNotesInput.value = profile.notes || '';
      if (controlMeta) {
        controlMeta.textContent = `drive=${Number(profile.drive_bias ?? 1).toFixed(2)} · feedback=${Number(profile.feedback_gain ?? 0).toFixed(2)} · clamp=${fmtNs(profile.safety_clamp_ns ?? 0)}`;
      }
    }

    function collectControlPayload() {
      return {
        drive_bias: Number(driveBiasInput?.value || 1.0),
        probe_window_ns: Number(probeWindowInput?.value || 120),
        feedback_gain: Number(feedbackGainInput?.value || 0),
        safety_clamp_ns: Number(safetyClampInput?.value || 0),
        thermal_guard_enabled: Boolean(thermalGuardToggle?.checked),
        notes: (controlNotesInput?.value || '').trim() || null,
      };
    }

    function wireControlInput(input, valueEl, formatter, onChange) {
      if (!input || !valueEl) return;
      input.addEventListener('input', () => {
        const v = Number(input.value || 0);
        valueEl.textContent = formatter(v);
        if (typeof onChange === 'function') onChange(v);
      });
    }

    async function loadControlProfile() {
      try {
        const profile = await apiGet('/controls/profile');
        applyControlProfileToUi(profile);
        if (controlStatus) controlStatus.textContent = 'Loaded from backend.';
      } catch (err) {
        if (controlStatus) controlStatus.textContent = `Could not load controls (${err.message})`;
      }
    }

    async function saveControlProfile() {
      const payload = collectControlPayload();
      if (applyControlsBtn) applyControlsBtn.disabled = true;
      if (controlStatus) controlStatus.textContent = 'Saving…';
      try {
        const profile = await apiPost('/controls/profile', payload);
        applyControlProfileToUi(profile);
        if (controlStatus) controlStatus.textContent = 'Controls pinned to backend profile.';
      } catch (err) {
        if (controlStatus) controlStatus.textContent = `Save failed: ${err.message}`;
      } finally {
        if (applyControlsBtn) applyControlsBtn.disabled = false;
      }
    }

    // --------------------------------------------
    // Visual KPI mapping (console scene)
    // --------------------------------------------
    function applyRunToVisuals(run) {
      const kpis = run?.kpis || {};
      const fidelity = (kpis.fidelity == null) ? null : Number(kpis.fidelity);
      const latency = (kpis.latency_us == null) ? null : Number(kpis.latency_us);
      const backaction = (kpis.backaction == null) ? null : Number(kpis.backaction);

      const atm = document.getElementById('blochAtmosphere');
      const noise = document.getElementById('blochNoise');
      const state = document.getElementById('blochState');
      const ringA = document.getElementById('blochRingA');
      const ringB = document.getElementById('blochRingB');
      const ringC = document.getElementById('blochRingC');
      const trace = document.getElementById('blochTrace');
      const orbitDot = document.getElementById('blochOrbitDot');
      const spark = document.getElementById('timelineSpark');

      if (atm) {
        const alpha = (fidelity == null || !Number.isFinite(fidelity))
          ? 0.38
          : (0.18 + clamp01(fidelity) * 0.55);
        atm.style.opacity = String(alpha.toFixed(3));
      }

      if (noise) {
        const n = (backaction == null || !Number.isFinite(backaction)) ? 0.18 : Math.max(0, Math.min(backaction, 0.6));
        noise.style.opacity = String((0.02 + (n / 0.6) * 0.18).toFixed(3));
      }

      const lat = (latency == null || !Number.isFinite(latency)) ? 60 : Math.max(5, Math.min(latency, 800));
      const spin = 12 + (lat / 800) * 22;          // 12–34s
      const dash = 2.6 + (lat / 800) * 2.2;        // 2.6–4.8s
      const sparkSpeed = 3.2 + (lat / 800) * 2.0;  // 3.2–5.2s

      const back = (backaction == null || !Number.isFinite(backaction)) ? 0.22 : Math.max(0, Math.min(backaction, 0.6));
      const orbit = 9 - (back / 0.6) * 3.5;        // 5.5–9.0s

      if (ringA) ringA.style.animationDuration = `${spin.toFixed(1)}s`;
      if (ringB) ringB.style.animationDuration = `${(spin * 1.3).toFixed(1)}s`;
      if (ringC) ringC.style.animationDuration = `${(spin * 1.9).toFixed(1)}s`;
      if (trace) trace.style.animationDuration = `${(spin * 1.4).toFixed(1)}s`;
      if (spark) spark.style.animationDuration = `${sparkSpeed.toFixed(1)}s`;
      if (state) state.style.animationDuration = `${orbit.toFixed(1)}s`;
      if (orbitDot) orbitDot.style.animationDuration = `${(spin * 0.55).toFixed(1)}s`;

      const paths = trace?.querySelectorAll?.('path') || [];
      paths.forEach((p, idx) => {
        const d = (idx === 0) ? dash : (dash * 1.2);
        p.style.animationDuration = `${d.toFixed(2)}s`;
      });
    }

    // --------------------------------------------
    // Qubit lattice visualization
    // --------------------------------------------
    function generateHexCoordinates(count) {
      if (!Number.isFinite(count) || count <= 0) return [];
      const coords = [{ q: 0, r: 0 }];
      if (count === 1) return coords;

      const directions = [
        { dq: 1, dr: 0 }, { dq: 1, dr: -1 }, { dq: 0, dr: -1 },
        { dq: -1, dr: 0 }, { dq: -1, dr: 1 }, { dq: 0, dr: 1 },
      ];

      let radius = 1;
      while (coords.length < count) {
        let q = radius;
        let r = 0;
        for (let side = 0; side < 6; side += 1) {
          const { dq, dr } = directions[side];
          for (let step = 0; step < radius; step += 1) {
            if (coords.length >= count) break;
            coords.push({ q, r });
            q += dq;
            r += dr;
          }
          if (coords.length >= count) break;
        }
        radius += 1;
      }
      return coords.slice(0, count);
    }

    function axialToPixel(coord, size) {
      const x = size * 1.5 * coord.q;
      const y = size * Math.sqrt(3) * (coord.r + coord.q / 2);
      return { x, y };
    }

    function renderQubitLattice(count, { demo = false, pulse = true } = {}) {
      if (!qubitLattice) return;
      const clampedCount = Math.max(1, Math.min(count || 1, 64));
      const coords = generateHexCoordinates(clampedCount);
      const size = 14;
      const pixels = coords.map(c => axialToPixel(c, size));
      const xs = pixels.map(p => p.x);
      const ys = pixels.map(p => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const pad = 24;
      const availableW = (qubitLattice.clientWidth || 360) - pad * 2;
      const availableH = (qubitLattice.clientHeight || 220) - pad * 2;
      const scaleX = availableW / Math.max(1, (maxX - minX));
      const scaleY = availableH / Math.max(1, (maxY - minY));
      const scale = Math.min(scaleX, scaleY);

      qubitLattice.innerHTML = '';
      pixels.forEach((p, idx) => {
        const node = document.createElement('div');
        node.className = 'qubit-node';
        if (demo) node.classList.add('demo');
        if (pulse && idx % 3 === 0) node.classList.add('pulse');
        if (idx % 5 === 0) node.classList.add('glow');
        node.style.left = `${pad + (p.x - minX) * scale}px`;
        node.style.top = `${pad + (p.y - minY) * scale}px`;
        node.style.animationDelay = `${(idx % 6) * 0.08}s`;
        qubitLattice.appendChild(node);
      });
    }

    function stopQubitDemo() {
      if (qubitDemoInterval) clearInterval(qubitDemoInterval);
      qubitDemoInterval = null;
    }

    function startQubitDemo() {
      stopQubitDemo();
      qubitDemoCount = 1;
      renderQubitLattice(qubitDemoCount, { demo: true });
      if (qubitCountDisplay) qubitCountDisplay.textContent = 'Demo: 1–25 qubits';
      if (qubitNote) qubitNote.textContent = 'Looping through 1–25 qubits until a live run completes.';
      qubitDemoInterval = setInterval(() => {
        qubitDemoCount = (qubitDemoCount % 25) + 1;
        renderQubitLattice(qubitDemoCount, { demo: true });
      }, 1400);
    }

    function applyQubitPanel(qubits, sessionTotal) {
      if (!qubitLattice) return;
      if (Number.isFinite(sessionTotal)) {
        sessionQubitTotal = sessionTotal;
        if (qubitSessionTotal) qubitSessionTotal.textContent = `Session total: ${sessionTotal.toLocaleString()} qubits`;
      }
      if (Number.isFinite(qubits) && qubits > 0) {
        latestQubitCount = qubits;
        stopQubitDemo();
        renderQubitLattice(qubits, { pulse: true });
        if (qubitCountDisplay) {
          qubitCountDisplay.textContent = `Live entanglement footprint: ${qubits.toLocaleString()} qubit${qubits === 1 ? '' : 's'}`;
        }
        if (qubitNote) {
          qubitNote.textContent = 'Counts update after each run once entanglement is detected. Session totals reflect your end-of-session footprint.';
        }
      } else if (!qubitDemoInterval) {
        startQubitDemo();
      }
    }

    async function refreshQubitPanel() {
      try {
        const data = await apiGet('/telemetry/qubits');
        applyQubitPanel(
          Number.isFinite(Number(data.last_run_qubits)) ? Number(data.last_run_qubits) : null,
          Number.isFinite(Number(data.session_total_qubits)) ? Number(data.session_total_qubits) : sessionQubitTotal
        );
      } catch (_) {
        if (!qubitDemoInterval) startQubitDemo();
      }
    }

    // --------------------------------------------
    // Neural orchestration graph
    // --------------------------------------------
    function clearWorkflowTimers() {
      workflowTimers.forEach(t => clearTimeout(t));
      workflowTimers = [];
    }

    function setWorkflowContextText(text) {
      if (workflowContext) workflowContext.textContent = text;
    }

    function defaultWorkflowTrace(run) {
      const hw = run?.hardware_target ? hardwareNameForId(run.hardware_target) : hardwareNameForId(hardwareSelect.value);
      const k = run?.kpis || {};
      const fidelityText = Number.isFinite(Number(k.fidelity)) ? `Fidelity est. ${Number(k.fidelity).toFixed(3)}` : 'DPD synchronization';
      const latencyText = Number.isFinite(Number(k.latency_us)) ? `${Number(k.latency_us).toFixed(1)} µs latency` : 'Latency sampling';
      const backactionText = Number.isFinite(Number(k.backaction)) ? `Backaction ${Number(k.backaction).toFixed(2)}` : 'Probe stability sweep';
      const standby = !run;
      return [
        { id: 'ingest', label: 'Ingest', description: standby ? `Standing by for the next SynQc run on ${hw}.` : `Budget + calibrations locked for ${hw}.`, percent_complete: 14, dwell_ms: 360 },
        { id: 'shape', label: 'Drive shaping', description: standby ? 'Preloading composite drive templates.' : `Drive bias tuned to ${Number(driveBiasInput?.value || 1).toFixed(2)}x; guardrails ${thermalGuardToggle?.checked === false ? 'off' : 'on'}.`, percent_complete: 32, dwell_ms: 520 },
        { id: 'probe', label: 'Probe', description: standby ? 'Probe window ready; waiting for execution trigger.' : `Mid-circuit probe at ${Number(probeWindowInput?.value || 120)} ns; feedback gain ${Number(feedbackGainInput?.value || 0).toFixed(2)}.`, percent_complete: 52, dwell_ms: 540 },
        { id: 'adapt', label: 'Adapt', description: standby ? 'Adaptive feedback buffers armed.' : `Adapting DPD feedback with clamp ${Number(safetyClampInput?.value || 0).toLocaleString()} ns.`, percent_complete: 72, dwell_ms: 520 },
        { id: 'infer', label: 'Infer', description: standby ? 'Neural estimator primed for incoming traces.' : `${fidelityText}. ${latencyText}.`, percent_complete: 88, dwell_ms: 620 },
        { id: 'commit', label: 'Commit', description: standby ? 'Awaiting results to commit.' : `${backactionText}. Shot budget ${(k.shot_budget || shotInput?.value || DEFAULT_SHOT_BUDGET)}`, percent_complete: 100, dwell_ms: 700 },
      ];
    }

    function normalizeWorkflowTrace(run) {
      const provided = (run && Array.isArray(run.workflow_trace) && run.workflow_trace.length)
        ? run.workflow_trace
        : defaultWorkflowTrace(run);
      return provided.map((step, idx) => {
        const pct = Number.isFinite(Number(step.percent_complete))
          ? Number(step.percent_complete)
          : ((idx + 1) / provided.length) * 100;
        const dwell = Number.isFinite(Number(step.dwell_ms)) ? Number(step.dwell_ms) : 480 + idx * 40;
        return {
          id: step.id || step.label || `step-${idx + 1}`,
          label: step.label || step.id || `Stage ${idx + 1}`,
          description: step.description || 'Workflow stage engaged.',
          percent_complete: Math.min(100, Math.max(0, pct)),
          dwell_ms: Math.max(140, dwell),
        };
      });
    }

    function workflowTraceSignature(trace) {
      if (!Array.isArray(trace)) return '';
      return trace.map(step => `${step.id || step.label}-${step.percent_complete}`).join('|');
    }

    function scheduleWorkflowRender(trace) {
      pendingWorkflowTrace = trace;
      if (workflowRenderRaf) return;
      workflowRenderRaf = requestAnimationFrame(() => {
        workflowRenderRaf = null;
        if (!pendingWorkflowTrace || !neuralWeb) return;

        const width = neuralWeb.clientWidth || 600;
        const height = neuralWeb.clientHeight || 220;
        const signature = `${width}x${height}:${workflowTraceSignature(pendingWorkflowTrace)}`;
        if (signature === lastWorkflowSignature) return;
        lastWorkflowSignature = signature;

        renderNeuralNetwork(pendingWorkflowTrace);
      });
    }

    function renderNeuralNetwork(trace) {
      if (!neuralWeb) return;
      if (!trace || !trace.length) {
        neuralNodePool.forEach(node => node.style.display = 'none');
        neuralLinkPool.forEach(link => link.style.display = 'none');
        return;
      }

      const width = neuralWeb.clientWidth || 600;
      const height = neuralWeb.clientHeight || 220;
      const stepCount = trace.length;
      const paddingX = Math.max(28, width * 0.08);
      const paddingY = Math.max(30, height * 0.22);
      const innerWidth = Math.max(0, width - paddingX * 2);
      const spacing = stepCount > 1 ? innerWidth / (stepCount - 1) : 0;
      const baseY = Math.min(height - paddingY, Math.max(paddingY, height * 0.5));
      const amplitude = Math.min(height * 0.18, Math.max(0, (height - paddingY * 2) / 2));

      let prev = null;
      trace.forEach((step, idx) => {
        const x = stepCount === 1 ? width * 0.5 : paddingX + spacing * idx;
        const y = baseY + Math.sin(idx * 1.18) * amplitude;
        const z = (idx % 3) * 12;

        if (prev) {
          const dx = x - prev.x;
          const dy = y - prev.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * 180 / Math.PI;
          let link = neuralLinkPool[idx - 1];
          if (!link) {
            link = document.createElement('div');
            link.className = 'neural-link';
            neuralLinkPool[idx - 1] = link;
          }
          if (!link.parentNode) neuralWeb.appendChild(link);
          link.style.width = `${length}px`;
          link.style.transform = `translate(${prev.x}px, ${prev.y}px) rotate(${angle}deg)`;
          link.style.display = '';
        }

        let node = neuralNodePool[idx];
        if (!node) {
          node = document.createElement('div');
          node.className = 'neural-node';
          const label = document.createElement('div');
          label.className = 'node-label';
          node.appendChild(label);
          node.labelEl = label;
          neuralNodePool[idx] = node;
        }
        if (!node.parentNode) neuralWeb.appendChild(node);
        node.classList.remove('active', 'completed');
        node.dataset.stepId = step.id || `step-${idx + 1}`;
        node.style.setProperty('--x', `${x}px`);
        node.style.setProperty('--y', `${y}px`);
        node.style.setProperty('--z', `${z}px`);
        node.title = step.description || step.label || '';
        node.style.display = '';

        node.labelEl.textContent = step.label || `Stage ${idx + 1}`;
        prev = { x, y };
      });

      for (let i = trace.length; i < neuralNodePool.length; i += 1) {
        neuralNodePool[i].style.display = 'none';
      }
      for (let i = Math.max(0, trace.length - 1); i < neuralLinkPool.length; i += 1) {
        neuralLinkPool[i].style.display = 'none';
      }
    }

    function playWorkflowTrace(trace) {
      if (!neuralWeb) return;
      clearWorkflowTimers();
      const nodes = Array.from(neuralWeb.querySelectorAll('.neural-node'));
      const links = Array.from(neuralWeb.querySelectorAll('.neural-link'));
      nodes.forEach(n => n.classList.remove('active', 'completed'));
      links.forEach(l => l.classList.remove('active'));

      if (!trace || !trace.length) {
        setWorkflowContextText('Waiting for the next SynQc run…');
        if (workflowProgressValue) workflowProgressValue.textContent = '0%';
        return;
      }

      let cumulativeDelay = 200;
      trace.forEach((step, idx) => {
        const node = nodes[idx];
        const link = idx > 0 ? links[idx - 1] : null;
        const delay = Math.max(140, step.dwell_ms || 480);
        const activate = () => {
          if (link) link.classList.add('active');
          if (node) {
            node.classList.add('active');
            requestAnimationFrame(() => node.classList.add('completed'));
          }
          setWorkflowContextText(step.description || step.label || 'Workflow stage engaged.');
          const pct = Math.min(100, Math.max(0, Number.isFinite(step.percent_complete) ? Number(step.percent_complete) : ((idx + 1) / trace.length) * 100));
          if (workflowProgressValue) workflowProgressValue.textContent = `${pct.toFixed(0)}%`;
        };
        workflowTimers.push(setTimeout(activate, cumulativeDelay));
        cumulativeDelay += delay;
      });

      const finalStep = trace[trace.length - 1];
      workflowTimers.push(setTimeout(() => {
        const pct = Math.min(100, Math.max(0, Number(finalStep?.percent_complete ?? 100)));
        if (workflowProgressValue) workflowProgressValue.textContent = `${pct.toFixed(0)}%`;
        if (finalStep?.description) setWorkflowContextText(finalStep.description);
      }, cumulativeDelay + 280));
    }

    function primeWorkflowFromRun(run) {
      activeWorkflowTrace = normalizeWorkflowTrace(run);
      scheduleWorkflowRender(activeWorkflowTrace);
      playWorkflowTrace(activeWorkflowTrace);
    }

    // --------------------------------------------
    // KPI rendering
    // --------------------------------------------
    function applyRunToKpis(run, ids) {
      const kpis = run?.kpis || {};
      const status = kpis.status || 'ok';

      const elFid = document.getElementById(ids.fidelity);
      const elLat = document.getElementById(ids.latency);
      const elBack = document.getElementById(ids.backaction);
      const elShots = document.getElementById(ids.shots);
      const elStatus = ids.status ? document.getElementById(ids.status) : null;

      // Fidelity
      if (!elFid) return;
      if (kpis.fidelity == null) {
        elFid.textContent = '—';
        elFid.classList.remove('kpi-good', 'kpi-warn', 'kpi-bad');
      } else {
        elFid.textContent = Number(kpis.fidelity).toFixed(3);
        setKpiClass(elFid, status);
      }

      // Latency
      if (elLat) {
        elLat.textContent = (kpis.latency_us == null) ? '—' : `${Number(kpis.latency_us).toFixed(1)} µs`;
      }

      // Backaction
      if (elBack) {
        if (kpis.backaction == null) {
          elBack.textContent = '—';
          elBack.classList.remove('kpi-good', 'kpi-warn', 'kpi-bad');
        } else {
          elBack.textContent = Number(kpis.backaction).toFixed(2);
          const ba = Number(kpis.backaction);
          if (ba > 0.35) setKpiClass(elBack, 'fail');
          else if (ba > 0.25) setKpiClass(elBack, 'warn');
          else setKpiClass(elBack, 'ok');
        }
      }

      // Shots
      if (elShots) {
        const used = Number(kpis.shots_used || 0);
        const budget = Number(kpis.shot_budget || 0);
        elShots.textContent = `${used.toLocaleString()} / ${budget.toLocaleString()}`;
      }

      if (elStatus) {
        elStatus.textContent = statusLabel(status);
        elStatus.classList.remove('kpi-good', 'kpi-warn', 'kpi-bad');
        // For a status value, color it similarly
        if (status === 'fail') elStatus.classList.add('kpi-bad');
        else if (status === 'warn') elStatus.classList.add('kpi-warn');
        else elStatus.classList.add('kpi-good');
      }

      // Only the console has visuals, but it doesn't hurt to try.
      try { applyRunToVisuals(run); } catch (_) { /* non-fatal */ }
    }

    const CONSOLE_KPI_IDS = {
      fidelity: 'kpiFidelity',
      latency: 'kpiLatency',
      backaction: 'kpiBackaction',
      shots: 'kpiShots',
      status: null,
    };

    const DETAILS_KPI_IDS = {
      fidelity: 'detailsKpiFidelity',
      latency: 'detailsKpiLatency',
      backaction: 'detailsKpiBackaction',
      shots: 'detailsKpiShots',
      status: 'detailsKpiStatus',
    };

    // --------------------------------------------
    // Interpretation text
    // --------------------------------------------
    function deriveInterpretationFromRun(run) {
      const hwName = hardwareNameForId(run.hardware_target);
      const k = run.kpis || {};
      const status = k.status || 'ok';

      if (run.error_code || run.error_message) {
        const msg = run.error_message || `Run failed on ${hwName}`;
        const hint = run.action_hint || run?.error_detail?.action_hint;
        return hint ? `${msg} (${run.error_code || ''}). ${hint}` : `${msg} (${run.error_code || ''}).`;
      }

      if (run.preset === 'health') {
        if (k.fidelity == null) {
          return `Health run completed on ${hwName}. Fidelity is not reported by this backend; inspect the record and provider logs.`;
        }
        const fid = Number(k.fidelity);
        const lat = (k.latency_us == null) ? null : Number(k.latency_us);
        const ba = (k.backaction == null) ? null : Number(k.backaction);

        const verdict =
          (status === 'fail') ? 'This looks unstable for production.' :
          (status === 'warn') ? 'This is borderline; watch drift and repeat a confirm run.' :
          'This looks stable inside normal bounds.';

        let extras = '';
        if (lat != null) extras += ` Latency was ~${lat.toFixed(1)} µs.`;
        if (ba != null) extras += ` Backaction was ${ba.toFixed(2)} (lower is better).`;

        return `Health diagnostics completed on ${hwName}. Estimated fidelity: ${fid.toFixed(3)}. ${verdict}${extras}`;
      }

      if (run.preset === 'hello_quantum_sim') {
        const lat = (k.latency_us == null) ? null : Number(k.latency_us);
        const ba = (k.backaction == null) ? null : Number(k.backaction);
        const extras = [];
        if (lat != null) extras.push(`latency ~${lat.toFixed(1)} µs`);
        if (ba != null) extras.push(`backaction ${ba.toFixed(2)}`);
        const suffix = extras.length ? ` (${extras.join(' · ')})` : '';
        return `Hello Quantum (Sim) completed on ${hwName}${suffix}. This preset is built to succeed so you can explore KPIs quickly.`;
      }

      if (run.preset === 'latency') {
        const lat = (k.latency_us == null) ? null : Number(k.latency_us);
        if (lat == null) return `Latency characterization completed on ${hwName}. Latency was not reported; inspect the record.`;
        const note = lat > 50 ? 'This is fairly slow; consider tighter scheduling / batching.' :
                     lat > 25 ? 'Moderate delay; keep an eye on drift and queueing.' :
                     'Fast path looks healthy.';
        return `Latency characterization completed on ${hwName}. End-to-end latency: ~${lat.toFixed(1)} µs. ${note}`;
      }

      if (run.preset === 'grover_demo') {
        const fid = Number.isFinite(Number(k.fidelity)) ? Number(k.fidelity) : null;
        const budget = Number.isFinite(Number(k.shot_budget)) ? Number(k.shot_budget) : null;
        const base = `Grover energy search completed on ${hwName}.`;
        const fidText = fid == null
          ? ' Fidelity was not reported by the backend; success probability will be derived from the returned counts.'
          : ` Estimated marked-state success ~${fid.toFixed(3)}.`;
        const budgetText = budget != null ? ` Adaptive shot cap: ${budget.toLocaleString()} shots.` : '';
        return `${base}${fidText}${budgetText}`;
      }

      if (run.preset === 'backend_compare') {
        return `Backend comparison run completed on ${hwName}. This API version returns a single KPI bundle; multi-backend A/B is a planned extension.`;
      }

      if (run.preset === 'grover_demo') {
        const fid = (k.fidelity == null) ? null : Number(k.fidelity);
        const success = (k.raw_counts && (k.raw_counts['10101'] || k.raw_counts['01010'])) ? 'Marked-state hits observed.' : 'Inspect counts to confirm marked-state hits.';
        const fidText = fid == null ? 'Fidelity reported by the backend circuit path.' : `Estimated fidelity ${fid.toFixed(3)} from Aer-backed sampling.`;
        return `Grover search executed on ${hwName}. ${fidText} ${success}`;
      }

      if (run.preset === 'dpd_demo') {
        return `DPD demo completed on ${hwName}. Use this run to validate the Drive–Probe–Drive timing story, then graduate to health/latency presets.`;
      }

      return `Experiment completed on ${hwName}.`;
    }

    function updateInterpretationText() {
      const preset = presetSelect.value;
      const hwName = hardwareSelect.options[hardwareSelect.selectedIndex]?.text || hardwareSelect.value;

      if (lastRun && lastRun.preset === preset && lastRun.hardware_target === hardwareSelect.value) {
        sceneInterpretation.textContent = deriveInterpretationFromRun(lastRun);
        return;
      }

      if (preset === 'health') {
        sceneInterpretation.textContent =
          'A Qubit Health Diagnostics bundle will estimate T1 and T2-like coherence times, ' +
          'and optionally gate error, on ' + hwName + '. The console will summarize whether this backend ' +
          'is within your historical stability band.';
      } else if (preset === 'hello_quantum_sim') {
        sceneInterpretation.textContent =
          'Hello Quantum (Sim) runs on the bundled simulator with forgiving guardrails so you always see KPIs, history, and details right away.';
      } else if (preset === 'latency') {
        sceneInterpretation.textContent =
          'Latency Characterization will run short DPD probes to measure control-to-readout delay on ' +
          hwName + ', helping you understand timing overhead and drift.';
      } else if (preset === 'backend_compare') {
        sceneInterpretation.textContent =
          'Backend A/B Comparison will replay a reference experiment on two backends and report ' +
          'relative fidelity, coherence, and latency, so you can choose which is better for your workload.';
      } else if (preset === 'grover_demo') {
        sceneInterpretation.textContent =
          'Grover search will compile a marked-state oracle + diffuser into a full Qiskit/Aer circuit so you can measure real shot-limited success rates instead of toy sampling.';
      } else if (preset === 'dpd_demo') {
        sceneInterpretation.textContent =
          'Guided SynQc DPD Example will show how a Drive–Probe–Drive sequence manipulates a single qubit ' +
          'over time, illustrating the link between SynQc theory and observable dynamics.';
      }
    }

    function normalizeShorRunForTable(run) {
      if (!run) return null;
      const idBase = run.run_id || run.id || run.uuid || null;
      const backend = run.provider_backend_name || run.backend_name || run.backend_mode || run.backend || 'shor';
      const method = run.method_used || run.method || run.kind || 'shor';
      const modulus = run.N ?? run.n ?? run.modulus;
      const runtime_us = Number.isFinite(run.runtime_ms) ? Number(run.runtime_ms) * 1000 : null;
      const status = run.ok === false ? 'fail' : (run.status || 'ok');
      let created_at = null;
      if (Number.isFinite(run.created_at)) {
        created_at = run.created_at > 1e12 ? Math.round(run.created_at / 1000) : run.created_at;
      } else {
        const parsed = Date.parse(run.ts_utc || run.created_at || '');
        if (Number.isFinite(parsed)) created_at = Math.round(parsed / 1000);
      }
      if (!Number.isFinite(created_at)) created_at = Math.round(Date.now() / 1000);

      const display_id = idBase ? String(idBase).split('-')[0] : 'shor';
      const control_profile = {
        shor: `${method} · ${backend}${modulus ? ` · N=${modulus}` : ''}`,
      };

      return {
        id: idBase ? `shor-${idBase}` : `shor-${created_at}`,
        _shorRunId: idBase || created_at,
        display_id,
        preset: 'shor',
        hardware_target: backend,
        created_at,
        kpis: { fidelity: null, latency_us: runtime_us, status },
        control_profile,
        error_code: status === 'fail' ? (run.error_code || 'shor_fail') : '',
        error_message: run.error_message,
        action_hint: run.action_hint,
      };
    }

    function experimentRunsWithShor() {
      const shorRuns = (shorRunsCache || []).map(normalizeShorRunForTable).filter(Boolean);
      const merged = [...recentRunsCache, ...shorRuns];
      return merged.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
    }

    // --------------------------------------------
    // Table rendering + filtering
    // --------------------------------------------
    function applyFilterToBody(tbody, filter) {
      const rows = tbody.querySelectorAll('tr');
      rows.forEach(row => {
        const p = row.dataset.preset || '';
        const failing = row.dataset.failing === '1';
        const show =
          (filter === 'all') ||
          (filter === 'health' && p === 'health') ||
          (filter === 'latency' && p === 'latency') ||
          (filter === 'compare' && p === 'backend_compare') ||
          (filter === 'grover' && p === 'grover_demo') ||
          (filter === 'dpd' && (p === 'dpd_demo' || p === 'hello_quantum_sim')) ||
          (filter === 'shor' && p === 'shor') ||
          (filter === 'failing' && failing);
        row.style.display = show ? '' : 'none';
      });
    }

    function renderFailureNotes() {
      const entries = Object.entries(failureByTarget || {}).sort((a, b) => (b[1] || 0) - (a[1] || 0));
      const text = entries.length
        ? `Most failing targets: ${entries.slice(0, 3).map(([t, c]) => `${t} (${c})`).join(', ')}`
        : 'No provider failures recorded yet.';
      if (failingTargetsConsole) failingTargetsConsole.textContent = text;
      if (failingTargetsExperiments) failingTargetsExperiments.textContent = text;
    }

    function buildRunRowStructure(includeId) {
      const tr = document.createElement('tr');
      tr.dataset.includeId = includeId ? '1' : '0';

      const tdTime = document.createElement('td');
      const tdId = document.createElement('td');
      const tdPreset = document.createElement('td');
      const tdHw = document.createElement('td');
      const tdFid = document.createElement('td');
      const tdLat = document.createElement('td');
      const tdCtrl = document.createElement('td');
      const tdErr = document.createElement('td');
      const tdStatus = document.createElement('td');

      const pill = document.createElement('span');
      tdStatus.appendChild(pill);

      tr.appendChild(tdTime);
      if (includeId) tr.appendChild(tdId);
      tr.appendChild(tdPreset);
      tr.appendChild(tdHw);
      tr.appendChild(tdFid);
      tr.appendChild(tdLat);
      tr.appendChild(tdCtrl);
      tr.appendChild(tdErr);
      tr.appendChild(tdStatus);

      tr._cells = {
        tdTime,
        tdId,
        tdPreset,
        tdHw,
        tdFid,
        tdLat,
        tdCtrl,
        tdErr,
        pill,
      };
      return tr;
    }

    function updateRunRow(tr, run, includeId) {
      const cells = tr._cells;
      tr.dataset.preset = run.preset;
      tr.dataset.id = run.id || run._shorRunId;
      tr.dataset.failing = ((run.error_code || '') !== '' || (run.kpis?.status === 'fail')) ? '1' : '0';

      const isShorRow = run.preset === 'shor' && Boolean(run._shorRunId);

      cells.tdTime.textContent = fmtTimeFromEpochSeconds(run.created_at);

      if (includeId) {
        const shortId = run.display_id || (run.id || '').split('-')[0] || run.id || run._shorRunId;
        cells.tdId.textContent = shortId || '—';
      }

      cells.tdPreset.textContent = presetLabel(run.preset);
      cells.tdHw.textContent = run.hardware_target;
      cells.tdFid.textContent = (run.kpis?.fidelity == null) ? '–' : Number(run.kpis.fidelity).toFixed(3);
      cells.tdLat.textContent = (run.kpis?.latency_us == null) ? '–' : `${Number(run.kpis.latency_us).toFixed(1)} µs`;
      cells.tdCtrl.textContent = summarizeControlProfile(run.control_profile);
      const errCode = run?.error_code || run?.error_detail?.code || '';
      const errMsg = run?.error_message || run?.error_detail?.message || '';
      const errHint = run?.action_hint || run?.error_detail?.action_hint || '';
      cells.tdErr.textContent = errCode || '—';
      cells.tdErr.title = [errMsg, errHint].filter(Boolean).join(' · ');
      cells.pill.className = `status-pill ${statusClass(run.kpis?.status)}`;
      cells.pill.textContent = statusLabel(run.kpis?.status);

      tr.onclick = () => {
        if (isShorRow) return openShorRun(run._shorRunId);
        return openDetails(run.id);
      };
      tr.style.display = '';
    }

    function renderRunTable(tbody, runs, { includeId, pool, emptyMessage, emptyColspan }) {
      const items = Array.isArray(runs) ? runs : [];
      if (!items.length) {
        pool.forEach(row => { row.style.display = 'none'; });
        if (!tbody._hintRow) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = emptyColspan;
          td.className = 'hint';
          tr.appendChild(td);
          tbody._hintRow = tr;
        }
        tbody._hintRow.firstChild.textContent = emptyMessage;
        if (!tbody._hintRow.parentNode) tbody.appendChild(tbody._hintRow);
        tbody._hintRow.style.display = '';
        return;
      }

      if (tbody._hintRow) tbody._hintRow.style.display = 'none';

      items.forEach((run, idx) => {
        let row = pool[idx];
        if (!row) {
          row = buildRunRowStructure(includeId);
          pool[idx] = row;
        }
        updateRunRow(row, run, includeId);
        if (!row.parentNode) tbody.appendChild(row);
      });

      for (let i = items.length; i < pool.length; i += 1) {
        pool[i].style.display = 'none';
      }
    }

    let consoleFilter = 'all';
    let experimentsFilter = 'all';
    let failureByTarget = {};

    function wireFilterPills(container, { onChange }) {
      if (!container) return;
      const pills = Array.from(container.querySelectorAll('.filter-pill'));
      pills.forEach(pill => {
        pill.addEventListener('click', () => {
          pills.forEach(x => x.classList.remove('active'));
          pill.classList.add('active');
          const f = pill.dataset.filter || 'all';
          onChange(f);
        });
      });
    }

    wireFilterPills(historyFiltersConsole, {
      onChange: (f) => {
        consoleFilter = f;
        applyFilterToBody(historyBody, consoleFilter);
      }
    });

    wireFilterPills(historyFiltersExperiments, {
      onChange: (f) => {
        experimentsFilter = f;
        applyFilterToBody(experimentsBody, experimentsFilter);
      }
    });

    // --------------------------------------------
    // Backend refresh + render
    // --------------------------------------------
    async function refreshFromBackend() {
      try {
        const h = await apiGet('/health');
        healthCache = h;
        failureByTarget = (h?.queue?.failures_by_target) || {};

        if (h && typeof h.max_shots_per_experiment === 'number') {
          MAX_SHOTS_PER_EXPERIMENT = h.max_shots_per_experiment;
          shotInput.max = String(MAX_SHOTS_PER_EXPERIMENT);
          if (shotLabel && Number.isFinite(MAX_SHOTS_PER_EXPERIMENT)) {
            shotLabel.textContent = `Shot budget (max ${MAX_SHOTS_PER_EXPERIMENT.toLocaleString()})`;
          }
        }

        if (h && typeof h.default_shot_budget === 'number') {
          DEFAULT_SHOT_BUDGET = h.default_shot_budget;
          const existing = Number.parseInt(String(shotInput?.value || ''), 10);
          if (!Number.isFinite(existing) || existing <= 0) shotInput.value = String(DEFAULT_SHOT_BUDGET);
        }

        if (h?.control_profile) {
          applyControlProfileToUi(h.control_profile);
          if (controlStatus) controlStatus.textContent = 'Live control profile loaded from /health.';
        }

        setRunStatus(`Backend: connected (${API_BASE}) · env=${h.env ?? 'unknown'} · version=${h.version ?? 'n/a'} · targets=${h.visible_target_count ?? 'n/a'}`);
        renderHealthSummary(h);

        // Targets
        try {
          const targets = await apiGet('/hardware/targets');
          const list = Array.isArray(targets?.targets) ? targets.targets : [];
          hardwareTargetsCache = list;

          // Update setup dropdown
          const current = hardwareSelect.value;
          while (hardwareSelect.firstChild) hardwareSelect.removeChild(hardwareSelect.firstChild);
          list.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t.id;
            opt.textContent = t.name;
            hardwareSelect.appendChild(opt);
          });
          if (Array.from(hardwareSelect.options).some(o => o.value === current)) {
            hardwareSelect.value = current;
          }
          hardwareSelect.dispatchEvent(new Event('change'));
          updateHardwareCapabilityHint();

          // Update hardware page
          renderHardwareList();
        } catch (_) { /* best effort */ }

        // Runs
        try {
          const recents = await apiGet('/experiments/recent?limit=50');
          recentRunsCache = Array.isArray(recents) ? recents : [];

          // Console history
          renderRunTable(historyBody, recentRunsCache, {
            includeId: false,
            pool: historyRowPool,
            emptyMessage: 'No runs yet.',
            emptyColspan: 8,
          });
          applyFilterToBody(historyBody, consoleFilter);

          // Experiments page table
          renderExperimentsTable();

          if (!lastRun && recentRunsCache.length) {
            primeWorkflowFromRun(recentRunsCache[0]);
          }
          if (recentRunsCache.length) {
            applyQubitPanel(recentRunsCache[0].qubits_used, sessionQubitTotal);
          }
        } catch (_) { /* ignore */ }

        renderFailureNotes();

      } catch (err) {
        setRunStatus(`Backend: not reachable (${API_BASE}). Start it and refresh.`);
        renderHealthSummary(null);
      }
      await refreshQubitPanel();
    }

    function debouncedRefreshFromBackend(delay = 200) {
      return new Promise(resolve => {
        refreshResolvers.push(resolve);
        if (refreshTimer) clearTimeout(refreshTimer);
        refreshTimer = setTimeout(async () => {
          refreshTimer = null;
          await refreshFromBackend();
          refreshResolvers.forEach(r => r());
          refreshResolvers = [];
        }, delay);
      });
    }

    function renderExperimentsTable() {
      const mergedRuns = experimentRunsWithShor();
      renderRunTable(experimentsBody, mergedRuns, {
        includeId: true,
        pool: experimentsRowPool,
        emptyMessage: 'No runs loaded.',
        emptyColspan: 9,
      });
      applyFilterToBody(experimentsBody, experimentsFilter);
    }

    function renderHardwareList() {
      if (!hardwareList) return;
      while (hardwareList.firstChild) hardwareList.removeChild(hardwareList.firstChild);

      const list = hardwareTargetsCache || [];
      if (!list.length) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.textContent = 'No targets loaded.';
        hardwareList.appendChild(empty);
        return;
      }

      list.forEach(t => {
        const item = document.createElement('div');
        item.className = 'hardware-item';
        item.setAttribute('role', 'listitem');

        const top = document.createElement('div');
        top.className = 'hardware-top';

        const name = document.createElement('div');
        name.className = 'hardware-name';
        name.textContent = t.name;

        const badge = document.createElement('div');
        badge.className = 'hardware-badge';
        badge.textContent = t.kind;

        top.appendChild(name);
        top.appendChild(badge);

        const meta1 = document.createElement('div');
        meta1.className = 'hardware-meta';
        meta1.textContent = `id: ${t.id}`;

        const meta2 = document.createElement('div');
        meta2.className = 'hardware-meta';
        meta2.textContent = t.description || '';

        const meta3 = document.createElement('div');
        meta3.className = 'hardware-meta';
        const summary = summarizeCapabilities(t.capabilities);
        meta3.textContent = summary || 'Capabilities: pending';

        item.appendChild(top);
        item.appendChild(meta1);
        item.appendChild(meta2);
        item.appendChild(meta3);

        hardwareList.appendChild(item);
      });
    }

    function updateHardwareCapabilityHint() {
      const cap = hardwareCapabilitiesForId(hardwareSelect.value);
      const summary = summarizeCapabilities(cap);
      if (hardwareCapabilityHint) {
        hardwareCapabilityHint.textContent = summary || 'Capabilities: not advertised';
      }

      const capMax = cap && Number.isFinite(cap.max_shots) ? Number(cap.max_shots) : null;
      const labelCeiling = Number.isFinite(capMax) ? capMax : MAX_SHOTS_PER_EXPERIMENT;
      if (shotLabel && Number.isFinite(labelCeiling)) {
        shotLabel.textContent = `Shot budget (max ${Number(labelCeiling).toLocaleString()})`;
      }
      if (shotInput && Number.isFinite(labelCeiling)) {
        shotInput.max = String(labelCeiling);
      }
    }

    async function runSelectedPreset() {
      const preset = presetSelect.value;
      const hardware_target = hardwareSelect.value;

      const control_overrides = collectControlPayload();

      let shot_budget = Number.parseInt(String(shotInput.value || ''), 10);
      if (!Number.isFinite(shot_budget) || shot_budget <= 0) shot_budget = DEFAULT_SHOT_BUDGET;
      const cap = hardwareCapabilitiesForId(hardware_target);
      const capMax = cap && Number.isFinite(cap.max_shots) ? Number(cap.max_shots) : null;
      const ceiling = Number.isFinite(capMax)
        ? Math.min(capMax, MAX_SHOTS_PER_EXPERIMENT)
        : MAX_SHOTS_PER_EXPERIMENT;
      shot_budget = Math.min(Math.max(shot_budget, 1), ceiling);

      const notes = (notesInput?.value || '').trim() || null;

      runPresetBtn.disabled = true;
      setRunStatus('Running preset…');

      try {
        const run = await apiPost('/experiments/run', { preset, hardware_target, shot_budget, notes, control_overrides });
        lastRun = run;

        // Update labels
        scenePresetLabel.textContent = presetLabel(preset).replace(' (T1/T2/RB)', '');
        sceneHardwareLabel.textContent = hardwareNameForId(hardware_target);

        applyRunToKpis(run, CONSOLE_KPI_IDS);
        sceneInterpretation.textContent = deriveInterpretationFromRun(run);
        primeWorkflowFromRun(run);
        applyQubitPanel(run.qubits_used, sessionQubitTotal);

        // Refresh lists
        await refreshFromBackend();

        setRunStatus(`Run complete · id=${run.id}`);
      } catch (err) {
        const payload = err?.response || {};
        const msg = payload.error_message || payload.message || err.message;
        const hint = payload.action_hint || payload?.error_detail?.action_hint;
        setRunStatus(`Run failed: ${msg}`);
        if (msg) {
          const summary = hint ? `${msg} · ${hint}` : msg;
          showRunAlert(summary);
        }
      } finally {
        runPresetBtn.disabled = false;
      }
    }

    runPresetBtn.addEventListener('click', runSelectedPreset);

    // --------------------------------------------
    // Details view: load experiment record
    // --------------------------------------------
    async function openDetails(experimentId) {
      selectedExperimentId = experimentId;
      setActiveView('details');
      await refreshDetailsView();
    }

    async function refreshDetailsView() {
      if (!selectedExperimentId) {
        detailsHeader.textContent = 'No experiment selected yet. Go to Experiments and click a row.';
        detailsInterpretation.textContent = 'Select a run to see a plain-language summary here.';
        detailsJson.textContent = '{}';
        if (detailsControlProfile) detailsControlProfile.textContent = 'Active controls: —';
        applyRunToKpis({ kpis: {} }, DETAILS_KPI_IDS);
        return;
      }

      try {
        const run = await apiGet(`/experiments/${selectedExperimentId}`);

        detailsHeader.textContent = `id=${run.id} · preset=${run.preset} · hardware=${hardwareNameForId(run.hardware_target)}`;
        detailsInterpretation.textContent = deriveInterpretationFromRun(run);
        const display = Object.assign({}, run);
        if (run.error_detail) display.error_detail = run.error_detail;
        detailsJson.textContent = JSON.stringify(display, null, 2);
        if (detailsControlProfile) {
          detailsControlProfile.textContent = `Active controls: ${summarizeControlProfile(run.control_profile)}`;
        }
        applyRunToKpis(run, DETAILS_KPI_IDS);
        primeWorkflowFromRun(run);
        // Update cache entries so tables show error codes for legacy runs
        recentRunsCache = recentRunsCache.map(r => (r.id === run.id ? run : r));
        renderExperimentsTable();
        applyFilterToBody(historyBody, consoleFilter);
        applyFilterToBody(experimentsBody, experimentsFilter);
      } catch (err) {
        detailsHeader.textContent = `Could not load id=${selectedExperimentId}`;
        detailsInterpretation.textContent = `Error: ${err.message}`;
        detailsJson.textContent = '{}';
        if (detailsControlProfile) {
          detailsControlProfile.textContent = 'Active controls: —';
        }
      }
    }

    detailsBackBtn.addEventListener('click', () => setActiveView(lastNonDetailsView));
    detailsReloadBtn.addEventListener('click', () => refreshDetailsView());

    // --------------------------------------------
    // Experiments / Hardware page controls
    // --------------------------------------------
    refreshExperimentsBtn.addEventListener('click', async () => {
      await debouncedRefreshFromBackend();
      renderExperimentsTable();
    });

    refreshHardwareBtn.addEventListener('click', async () => {
      await debouncedRefreshFromBackend();
      renderHardwareList();
    });

    function refreshExperimentsView(){
      // If we already have cache, render immediately; otherwise fetch.
      if (recentRunsCache && recentRunsCache.length) {
        renderExperimentsTable();
      } else {
        debouncedRefreshFromBackend();
      }
    }

    function refreshHardwareView(){
      if (hardwareTargetsCache && hardwareTargetsCache.length) {
        renderHardwareList();
      } else {
        debouncedRefreshFromBackend();
      }
    }

    // --------------------------------------------
    // Chat: safe rendering (no innerHTML)
    // --------------------------------------------
    function appendMessage(text, who) {
      const div = document.createElement('div');
      div.className = 'msg ' + (who === 'user' ? 'msg-user' : 'msg-agent');

      const label = document.createElement('strong');
      label.textContent = (who === 'user' ? 'You:' : 'SynQc Guide:');

      div.appendChild(label);
      div.appendChild(document.createTextNode(' '));
      div.appendChild(document.createTextNode(String(text)));

      chatPanel.appendChild(div);
      chatPanel.scrollTop = chatPanel.scrollHeight;
    }

      function interpretIntent(msg) {
        const lower = msg.toLowerCase();
        if (lower.includes('health') || lower.includes('stable') || lower.includes('coherence')) {
          presetSelect.value = 'health';
          scenePresetLabel.textContent = 'Qubit Health Diagnostics';
          return 'I will configure the Qubit Health Diagnostics suite (T1/T2*/echo, optional RB) ' +
                 'for your selected backend. You can refine shot budget or backend in the Setup tab.';
        }
        if (lower.includes('hello quantum')) {
          presetSelect.value = 'hello_quantum_sim';
          scenePresetLabel.textContent = 'Hello Quantum (Sim)';
          return 'I will run the Hello Quantum (Sim) quickstart on the local simulator so you can see KPIs immediately.';
        }
        if (lower.includes('latency')) {
          presetSelect.value = 'latency';
          scenePresetLabel.textContent = 'Latency Characterization';
          return 'I will prepare a Latency Characterization bundle with low-shot DPD probes to measure ' +
                 'end-to-end and backend-only delay.';
      }
      if (lower.includes('compare') || lower.includes('backend')) {
        presetSelect.value = 'backend_compare';
        scenePresetLabel.textContent = 'Backend A/B Comparison';
        return 'I will set up a backend comparison run: your reference experiment will be replayed on two ' +
               'backends so we can compare fidelity and latency directly.';
      }
      if (lower.includes('example') || lower.includes('demo')) {
        presetSelect.value = 'dpd_demo';
        scenePresetLabel.textContent = 'Guided SynQc DPD Example';
        return 'I will walk you through a guided SynQc Drive–Probe–Drive example on a local simulator, ' +
               'explaining each step as we go.';
      }
      return 'I have recorded your goal. Use the Setup tab to pick the closest preset (Health, Latency, ' +
             'Backend Compare, or DPD Demo) and I will adapt it to your backend and constraints.';
    }

    agentSend.addEventListener('click', () => {
      const text = agentInput.value.trim();
      if (!text) return;
      appendMessage(text, 'user');
      agentInput.value = '';
      const reply = interpretIntent(text);
      appendMessage(reply, 'agent');
      updateInterpretationText();
    });

    agentInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') agentSend.click();
    });

    wireControlInput(driveBiasInput, driveBiasValue, v => `${Number(v).toFixed(2)}x`);
    wireControlInput(probeWindowInput, probeWindowValue, fmtNs);
    wireControlInput(feedbackGainInput, feedbackGainValue, v => Number(v).toFixed(2));
    wireControlInput(safetyClampInput, safetyClampValue, fmtNs);
    wireControlInput(spectralShiftInput, spectralShiftValue, fmtDeg, setSpectralShift);
    if (applyControlsBtn) applyControlsBtn.addEventListener('click', saveControlProfile);
    applyControlProfileToUi(collectControlPayload());
    hydrateSpectralShiftFromStorage();

    hardwareSelect.addEventListener('change', () => {
      sceneHardwareLabel.textContent = hardwareSelect.options[hardwareSelect.selectedIndex]?.text || hardwareSelect.value;
      updateHardwareCapabilityHint();
      updateInterpretationText();
    });

    presetSelect.addEventListener('change', () => {
      const val = presetSelect.value;
      scenePresetLabel.textContent = presetLabel(val);
      updateInterpretationText();
    });

    if (neuralWeb) {
      if ('ResizeObserver' in window) {
        const neuralObserver = new ResizeObserver(() => {
          scheduleWorkflowRender(activeWorkflowTrace);
        });
        neuralObserver.observe(neuralWeb);
      } else {
        window.addEventListener('resize', () => scheduleWorkflowRender(activeWorkflowTrace));
      }
    }

    // --------------------------------------------
    // Boot
    // --------------------------------------------
    primeWorkflowFromRun(lastRun);
    startQubitDemo();
    initShorPanel();
    refreshFromBackend();
    updateInterpretationText();
  </script>
</body>
</html>
